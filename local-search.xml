<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C/C++ 模板元编程学习</title>
    <link href="/2025/01/TemplateMetaprogramming/"/>
    <url>/2025/01/TemplateMetaprogramming/</url>
    
    <content type="html"><![CDATA[<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>在C++中使用模板（templates）来进行泛型编程，它允许程序员编写与数据类型无关的代码，模板可以是函数模板或类模板。</p><h3 id="模板形式"><a href="#模板形式" class="headerlink" title="模板形式"></a>模板形式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 函数模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">int</span> i = <span class="hljs-number">76</span>&gt;<br>T <span class="hljs-built_in">func</span>(T t) &#123;<br>  std::cout &lt;&lt; i &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> t * <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// 类模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T t)</span> </span>&#123; std::cout &lt;&lt; t &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// 调用函数模板</span><br>  std::cout &lt;&lt; <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>) &lt;&lt; std::endl;<br>  std::cout &lt;&lt; <span class="hljs-built_in">func</span>(<span class="hljs-number">1.1</span>) &lt;&lt; std::endl;<br><br>  <span class="hljs-comment">// 调用类模板</span><br>  MyClass&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数模板可以自动推导参数类型，如上例中的<code>func(1.1)</code>。</p><p>模板参数也可以有默认值，此时调用者在调用时没有指定时，会使用默认值。</p><p>在函数模板中，为了一些特殊情况，可以添加一个同名函数，它可以与函数模板重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function">T <span class="hljs-title">twice</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> t * <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-function">std::string <span class="hljs-title">twice</span><span class="hljs-params">(std::string t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> t + t;<br>&#125;<br></code></pre></td></tr></table></figure><p>整数也可以作为模板参数，比如<code>template &lt;int N&gt;</code>，但模板参数只支持整数类型（包括<code>enum</code>），浮点类型、指针类型，不能声明为模板参数</p><p>整数作为函数参数和模板参数的区别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> N&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span></span>;<br></code></pre></td></tr></table></figure><p>template <int N> 传入的 N，是一个<strong>编译期常量</strong>，每个不同的 N，编译器都会单独生成一份代码，从而可以对他做单独的优化；而 func(int N)，则变成<strong>运行期变量</strong>，编译器无法自动优化，只能运行时得知被调用参数 N 的不同。</p><p>一个编译期优化例子是函数中需要根据<code>debug</code>参数控制是否输出调试信息。<br>如果将参数作为函数参数，那么无论是否为<code>true</code>，每次调用时都要进行判断，影响性能；而作为模板参数，编译器会生成两份函数<code>func&lt;true&gt;</code>和<code>func&lt;false&gt;</code>，前者保留了调试用的打印语句，后者则完全为性能优化而可以去掉打印语句。</p><h3 id="模板的难题"><a href="#模板的难题" class="headerlink" title="模板的难题"></a>模板的难题</h3><h4 id="编译期常量"><a href="#编译期常量" class="headerlink" title="编译期常量"></a>编译期常量</h4><p>调用模板时，填入的参数为编译期常量，不能通过<strong>运行时变量</strong>组成的表达式来指定。<br>可以通过<code>constexpr</code>关键字定义编译期常量，比如<code>constexpr int i = 1</code>，当然，定义时<code>=</code>右边的值也必须是编译期常量。</p><h4 id="分文件编写"><a href="#分文件编写" class="headerlink" title="分文件编写"></a>分文件编写</h4><p>如果像使用传统函数一样分离函数模板的声明和定义，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* my_sum.h */</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">bool</span> debug&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">my_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>;<br><br><span class="hljs-comment">/* my_sum.cpp */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_sum.h&quot;</span></span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">bool</span> debug&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">my_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>  <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    res += i;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(debug)</span> </span>&#123;<br>    std::cout &lt;&lt; res &lt;&lt; std::endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/* main.cpp */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_sum.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-built_in">my_sum</span>&lt;<span class="hljs-literal">true</span>&gt;(<span class="hljs-number">4</span>) &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时编译则会报如下错误：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">undefined reference to `int my_sum&lt;<span class="hljs-literal">true</span>&gt;(int)<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><p>这是因为编译器对模板的编译是<strong>惰性</strong>的，只有在定义模板的<code>.cpp</code>文件中去使用该模板时，该模板才会被真正实例化。<br>在上述例子中，<code>my_sum.cpp</code>由于并未使用到定义的函数模板，所以单独编译后并没有函数符号<code>int my_sum&lt;true&gt;(int)</code>，所以在链接阶段<code>main.cpp</code>中调用时找不到相应的函数实现，所以会报链接错误。<br>解决办法：在定义模板的<code>.cpp</code>文件增加显式编译模板的声明，比如上述例子可以加一行<code>template int my_sum&lt;true&gt;(int);</code>。<br>可以看出，我们每在<code>main.cpp</code>中使用一款“新的”模板实例，都需要显式地去在定义处更改，使得编译出这个实例，这显然不合理。所以一般使用模板时会将声明和定义一起放在头文件中，引用时就相当于将整份代码复制过来，调用时在产生新的模板实例。<br>从这一点也能知道，stl头文件不是像以前C中的头文件一样，只有声明，在编译时链接动态库；而是将如何定义的全写在头文件中了。</p><h2 id="模板元编程"><a href="#模板元编程" class="headerlink" title="模板元编程"></a>模板元编程</h2><p><strong>Metaprogramming</strong> is the writing of computer programs:</p><ul><li>That write or manipulate other programs (or themselves) as their data, or</li><li>That do… work at compile time that would otherwise be done at runtime”</li></ul><p>C++ <strong>Template Metaprogramming</strong> uses <strong>template instantiation</strong> to drive <strong>compile-time evaluation</strong>:<br>When we use the name of a template where a (function, type, variable) is expected, the compiler will instantiate (create) the expected entity from that template.</p><p>模板元编程能够带来以下好处：</p><ul><li><strong>提高源代码的灵活性</strong></li><li><strong>提高运行时性能</strong></li></ul><p>使用模板元编程时，有一些限制需要注意：</p><ul><li><strong>不可变性（No Mutability）</strong></li><li><strong>无虚函数（No Virtual Functions）</strong></li><li><strong>无运行时类型信息（No RTTI）</strong></li></ul><p>总结来说，模板元编程的核心思想是将工作从<strong>运行时</strong>转移到<strong>编译时</strong>。</p><h3 id="示例：编译时计算绝对值（Compile-time-Absolute-Value）"><a href="#示例：编译时计算绝对值（Compile-time-Absolute-Value）" class="headerlink" title="示例：编译时计算绝对值（Compile-time Absolute Value）"></a>示例：编译时计算绝对值（Compile-time Absolute Value）</h3><p>下面是一个简单的编译时绝对值元函数（<code>metafunction</code>）的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">my_abs</span> &#123;<br>  <span class="hljs-built_in">static_assert</span>(N != INT_MIN);  <span class="hljs-comment">// 避免绝对值计算溢出</span><br>  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = (N &lt; <span class="hljs-number">0</span>) ? -N : N;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个元函数功能类似于一个<code>constexpr</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">abs</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> </span>&#123; <span class="hljs-keyword">return</span> (N &lt; <span class="hljs-number">0</span>) ? -N : N; &#125;<br></code></pre></td></tr></table></figure><p>但作为<code>struct</code>，元函数提供了更多的功能，例如：</p><ul><li>Public member <code>type declarations</code> (e.g., typedef or using).</li><li>Public member <code>data declarations</code> (static const&#x2F;constexpr, each initialized via a constant expression).</li><li>Public member <code>function declarations</code> and <code>constexpr member function definitions</code>.</li><li>Public member templates, static_asserts, and more!</li></ul><h3 id="示例：编译时递归与特化"><a href="#示例：编译时递归与特化" class="headerlink" title="示例：编译时递归与特化"></a>示例：编译时递归与特化</h3><p>另一个编译时数值计算的例子是计算最大公约数（GCD）。我们可以通过编译时递归和特化来实现这一点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// primary template</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">unsigned</span> M, <span class="hljs-type">unsigned</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">my_gcd</span> &#123;<br>  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = my_gcd&lt;N, M % N&gt;::value;<br>&#125;;<br><span class="hljs-comment">// partial specialization 部分特化作为递归的base</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">unsigned</span> M&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">my_gcd</span>&lt;M, <span class="hljs-number">0</span>&gt; &#123;<br>  <span class="hljs-built_in">static_assert</span>(M != <span class="hljs-number">0</span>);<br>  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = M;<br>&#125;;<br></code></pre></td></tr></table></figure><p>解释:</p><ul><li><strong>模板的定义</strong>：我们需要先在<code>template</code>后给出实例化时的参数，随后可以定义相应的函数模板、类模板等。</li><li><strong>模板特化</strong>：特化模板需要放在已定义的模板之后。在<code>template</code>后给出尚未确定的参数，在模板名称后用<code>&lt;&gt;</code>按照<code>primary template</code>定义的格式进行实例化，并给出特定情况下的模板定义。</li></ul><p>模板的使用本质上是模板实例化，就像函数调用一样将“实参”填入形参。这类似于<strong>模式匹配</strong>，当出现多个匹配时，特化模板的匹配优先级较高，最终选择最“特别”的模板来进行实例化。因此，多个特化模板都位于主模板的范围内，但每个实例化就像<code>if</code>语句一样，而主模板则作为最后的默认情况。</p><h3 id="将type作为参数"><a href="#将type作为参数" class="headerlink" title="将type作为参数"></a>将<code>type</code>作为参数</h3><p><code>sizeof</code> 是 C++ 提供的一个接受 <code>type</code> 作为参数的内置操作符。类似地，我们可以通过编写自定义的元函数，来实现类型相关的操作。</p><p>示例：获取<code>array</code>类型的<code>rank</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// primary template</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rank</span> &#123;<br>  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> value = <span class="hljs-number">0u</span>;<br>&#125;;<br><span class="hljs-comment">// partial specialization</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">size_t</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rank</span>&lt;T[N]&gt; &#123;<br>  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> value = <span class="hljs-number">1u</span> + rank&lt;T&gt;::value;<br>&#125;;<br></code></pre></td></tr></table></figure><p>该例子说明：</p><ul><li>可以将<code>type</code>作为参数，存在<code>type metafunction</code></li><li>递归操作不仅可以在主模板（<code>primary</code>）中进行，也可以在模板特化（<code>specialization</code>）中进行。</li></ul><h3 id="将type作为结果"><a href="#将type作为结果" class="headerlink" title="将type作为结果"></a>将<code>type</code>作为结果</h3><p>许多元函数需要一个或多个<code>type</code>，然后返回一个<code>type</code>。</p><p>示例：返回移除掉<code>const</code>的相同类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// primary</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_const</span> &#123;<br>  <span class="hljs-keyword">using</span> type = T;<br>&#125;;<br><span class="hljs-comment">// partial specialization</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_const</span>&lt;T <span class="hljs-type">const</span>&gt; &#123;<br>  <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> remove_const&lt;T&gt;::type;<br>&#125;;<br><span class="hljs-comment">// alias</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">using</span> <span class="hljs-type">remove_const_t</span> = <span class="hljs-keyword">typename</span> remove_const&lt;T&gt;::type;<br></code></pre></td></tr></table></figure><h3 id="C-元函数的约定-1：struct中的type"><a href="#C-元函数的约定-1：struct中的type" class="headerlink" title="C++ 元函数的约定#1：struct中的type"></a>C++ 元函数的约定#1：struct中的<code>type</code></h3><ul><li>元函数有类型结果的话用<strong>type</strong>命名<br>示例：An identity metafunction<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 返回输入类型的类型</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">type_is</span> &#123;<br>  <span class="hljs-keyword">using</span> type = T;<br>&#125;;<br></code></pre></td></tr></table></figure>可以通过继承（<strong>inheritance</strong>）使用上面的简单元函数（以之前移除<code>const</code>为例）：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_const</span> : type_is&lt;T&gt; &#123;&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_const</span>&lt;T <span class="hljs-type">const</span>&gt; : type_is&lt;T&gt; &#123;&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">using</span> <span class="hljs-type">remove_const_t</span> = <span class="hljs-keyword">typename</span> remove_const&lt;T&gt;::type;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Compile-time-decision-making"><a href="#Compile-time-decision-making" class="headerlink" title="Compile-time decision-making"></a>Compile-time decision-making</h3><p>如果一个元函数可以根据某个条件在编译期返回不同的类型，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">bool</span> p, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">F</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">IF</span> : type_is&lt;...&gt; &#123;&#125;; <span class="hljs-comment">// p ? T : F</span><br></code></pre></td></tr></table></figure><p>那么可以让我们写出<code>self-configuring code</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 比如代码中有一个常量q</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> q = ...;<br><span class="hljs-comment">// k 被声明为两种类型之一</span><br>IF_t&lt;(q &lt; <span class="hljs-number">0</span>), <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span>&gt; k;<br><span class="hljs-comment">//调用两个函数之一</span><br>IF_t&lt;(q &lt; <span class="hljs-number">0</span>), F, G&gt;&#123;&#125;(...)<br><span class="hljs-comment">// 继承两个基类之一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">public</span> IF_t&lt;(q &lt; <span class="hljs-number">0</span>), B1, B2&gt; &#123;...&#125;;<br></code></pre></td></tr></table></figure><p><code>IF</code>可以被实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// primary</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">bool</span> p, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">F</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">IF</span> : type_is&lt;T&gt; &#123;&#125;;<br><span class="hljs-comment">// specialization</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">F</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">IF</span>&lt;<span class="hljs-literal">false</span>, T, F&gt; : type_is&lt;F&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure><p>而对于单类型的判断，也就是“如果<code>true</code>，返回该类型；否则，无返回”,则实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// primary</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">bool</span> p, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> = <span class="hljs-type">void</span>&gt;<br><span class="hljs-keyword">struct</span> enable_if : type_is&lt;T&gt; &#123;&#125;;<br><span class="hljs-comment">// specialization</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">enable_if</span>&lt;<span class="hljs-literal">false</span>, T&gt; &#123;&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">bool</span> p, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> = <span class="hljs-type">void</span>&gt;<br><span class="hljs-keyword">using</span> <span class="hljs-type">enable_if_t</span> = <span class="hljs-keyword">typename</span> enable_if&lt;p, T&gt;::type;<br></code></pre></td></tr></table></figure><p>此时，若实例化时匹配到特化部分，也就是发生<code>enable_if&lt;false, ...&gt;::type</code>，也不一定就会发生编译错误，这就是<strong>SFINAE</strong>特性。</p><h3 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a>SFINAE</h3><p><strong>SFINAE</strong>: Substitution Failure is Not An Error.</p><p>在模板实例化时，也就是发生模板调用时，会发生：</p><ul><li>获取模板参数：<ul><li>调用时直接给出</li><li>函数模板可以通过函数参数来推断</li><li>使用模板默认参数</li></ul></li><li>对相应的模板占位参数进行替换<br>此时，如果得到正确的代码，则实例化成功；但如果结果代码是不合法的（视为替换失败（<strong>Substitution Failure</strong>）），则会被静默丢掉（<strong>be silently discarded</strong>），继续寻找下一个。</li></ul><p>应用<strong>SFINAE</strong>的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">enable_if_t</span>&lt;std::is_integral_v&lt;T&gt;, <span class="hljs-type">int</span>&gt; <span class="hljs-built_in">f</span>(T val) &#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;using int&quot;</span> &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> val;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">enable_if_t</span>&lt;std::is_floating_point_v&lt;T&gt;, <span class="hljs-type">float</span>&gt; <span class="hljs-built_in">f</span>(T val) &#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;using float&quot;</span> &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> val;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于以上函数模板，在调用<code>f&lt;&gt;()</code>时，如果<code>val</code>是整型，则会调用第一个；若是浮点型，则会调用第二个；若都不是（比如字符串），这时，两个模板都替换失败，才会报出编译器错误。</p><p>C++20出现了<code>concept</code>，它可以去除上述“别扭”的写法，上述的目的就是在函数调用时，<strong>根据参数类型的不同来实例化不同的模板实现</strong>，做法则是在一个实现中通过元函数来保证只有类型满足某某条件后才能生成正确的代码，让不满足的出错继而另寻他路，也就是对类型本身的限制条件。可以把这些限制和约束抽象成<code>concept</code>，那写法变成如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 原写法：通过enable_if_t制造限制</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">enable_if_t</span>&lt;std::is_integral_v&lt;T&gt;, <span class="hljs-type">int</span>&gt; <span class="hljs-built_in">f</span>(T val) &#123;<br>  ...<br>&#125;;<br><span class="hljs-comment">// 新写法：定义一个concept `Integral`，写出受限的模板实现</span><br><span class="hljs-keyword">template</span> &lt;Integral T&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(T val)</span> </span>&#123;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="C-元函数的约定-2：struct中的value"><a href="#C-元函数的约定-2：struct中的value" class="headerlink" title="C++ 元函数的约定#2：struct中的value"></a>C++ 元函数的约定#2：struct中的<code>value</code></h3><p>A metafunction with a value result has:</p><ul><li>A <code>static constexpr</code> member, <code>value</code>, giving its result, and…</li><li>A few convenience member types and <code>constexpr</code> functions.</li></ul><p>一个规范的<strong>value-returning</strong>元函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, T v&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">integral_constant</span> &#123;<br>  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> T value = v;<br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">T</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> T <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其他<strong>value-returning</strong>元函数可以继承该类。</p><p>将原先的<code>rank</code>改写如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rank</span> : integral_constant&lt;<span class="hljs-type">size_t</span>, <span class="hljs-number">0u</span>&gt; &#123;&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">size_t</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rank</span>&lt;T[N]&gt; : integral_constant&lt;<span class="hljs-type">size_t</span>, <span class="hljs-number">1u</span> + rank&lt;T&gt;::value&gt; &#123;&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rank</span>&lt;T[]&gt; : integral_constant&lt;<span class="hljs-type">size_t</span>, <span class="hljs-number">1u</span> + rank&lt;T&gt;::value&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure><p>一些派生的类型别名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">bool</span> b&gt;<br><span class="hljs-keyword">using</span> bool_constant = integral_constant&lt;<span class="hljs-type">bool</span>, b&gt;;<br><br><span class="hljs-keyword">using</span> true_type = bool_constant&lt;<span class="hljs-literal">true</span>&gt;;<br><span class="hljs-keyword">using</span> false_type = bool_constant&lt;<span class="hljs-literal">false</span>&gt;;<br></code></pre></td></tr></table></figure><p><strong>value-returning</strong>元函数的不同调用方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">is_void&lt;T&gt;::<span class="hljs-function">value</span><br><span class="hljs-function"><span class="hljs-title">bool</span><span class="hljs-params">(is_void&lt;T&gt;&#123;&#125;)</span>  <span class="hljs-comment">// instantiate/cast</span></span><br><span class="hljs-function">is_void&lt;T&gt;</span>&#123;&#125;()      <span class="hljs-comment">// instantiate/call</span><br>is_void_v&lt;T&gt;<br></code></pre></td></tr></table></figure><p>同时利用继承、特化的一些例子：给一个类型，判断是否是 void</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// primary</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_void</span> : false_type &#123;&#125;;<br><span class="hljs-comment">// specialization 共4种</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_void</span>&lt;<span class="hljs-type">void</span>&gt; : true_type &#123;&#125;;<br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_void</span>&lt;<span class="hljs-type">void</span> <span class="hljs-type">const</span>&gt; : true_type &#123;&#125;;<br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_void</span>&lt;<span class="hljs-type">void</span> <span class="hljs-keyword">volatile</span>&gt; : true_type &#123;&#125;;<br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_void</span>&lt;<span class="hljs-type">void</span> <span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span>&gt; : true_type &#123;&#125;;<br></code></pre></td></tr></table></figure><p>除了这种方式，也可以委托给其他元函数来实现这个需求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 给两种类型，判断是否相同 */</span><br><span class="hljs-comment">// primary</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">U</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_same</span> : false_type &#123;&#125;;<br><span class="hljs-comment">// specialization</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_same</span>&lt;T, T&gt; : true_type &#123;&#125;;<br><br><span class="hljs-comment">/* 移除 const 和 volatile */</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">using</span> remove_cv = remove_volatile&lt;<span class="hljs-type">remove_const_t</span>&lt;T&gt;&gt;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">using</span> <span class="hljs-type">remove_cv_t</span> = <span class="hljs-keyword">typename</span> remove_cv&lt;T&gt;::type;<br><br><span class="hljs-comment">/* 利用上述元函数实现 is_void */</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">using</span> is_void = is_same&lt;<span class="hljs-type">remove_cv_t</span>&lt;T&gt;, <span class="hljs-type">void</span>&gt;;<br></code></pre></td></tr></table></figure><h3 id="在元函数中使用参数包（parameter-pack）"><a href="#在元函数中使用参数包（parameter-pack）" class="headerlink" title="在元函数中使用参数包（parameter pack）"></a>在元函数中使用参数包（<code>parameter pack</code>）</h3><p>一些元函数中，我需要任意长的参数列表（比如需要任意多个类型参数），此时可以借助参数包实现。</p><p>示例：判断某个类型是否与一堆类型中的某个相同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// primary</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span>... P0toN&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_one_of</span>;<br><span class="hljs-comment">// base #1: specialization recognizes empty list of types</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_one_of</span>&lt;T&gt; : false_type &#123;&#125;;<br><span class="hljs-comment">// base #2: specialization recognizes match at head of list of types</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span>... P1toN&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_one_of</span>&lt;T, T, P1toN...&gt; : true_type &#123;&#125;;<br><span class="hljs-comment">// base #3: specialization recogniazes mismatch at head of list of types</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">P0</span>, <span class="hljs-keyword">class</span>... P1toN&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_one_of</span>&lt;T, P0, P1toN...&gt; : is_one_of&lt;T, P1toN...&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure><p>可以再次实现<code>is_void</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">using</span> is_void = is_one_of&lt;T, <br>                          <span class="hljs-type">void</span>, <br>                          <span class="hljs-type">void</span> <span class="hljs-type">const</span>, <br>                          <span class="hljs-type">void</span> <span class="hljs-keyword">volatile</span>, <br>                          <span class="hljs-type">void</span> <span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span><br>                          &gt;;<br></code></pre></td></tr></table></figure><h3 id="Unevaluated-operands"><a href="#Unevaluated-operands" class="headerlink" title="Unevaluated operands"></a>Unevaluated operands</h3><p>Operands of <code>sizeof</code>, <code>typeid</code>, <code>decltype</code>, and <code>noexcept</code> are <strong>never evaluated</strong>, not even at compile time:</p><ul><li>Implies that no code is generated (in these contexts) for such <strong>operand expressions</strong>, and…</li><li>Implies that we need only a <strong>declaration</strong>, not a <strong>definition</strong>, to use a (function’s or object’s) name in these contexts.</li></ul><p>An unevaluated function call (e.g., to foo) can usefully map one type to another:</p><ul><li>decltype( foo(declval<T>()) )</li></ul><p><code>std::declval</code>是函数模板，但只有声明，没有定义，无法真正调用它；<code>std::declval&lt;T&gt;()</code>被声明为给出类型T的右值结果（std::declval&lt;T&amp;&gt;()给出左值）；但因为没有定义，所以并不会真正返回，这正好可以用在这种<strong>unevaluated</strong>的场景下，它的作用是<strong>假装这里有一个这种类型的值</strong>。<br>此时，整体考虑上述的<code>decltype( foo(declval&lt;T&gt;()) )</code>：<br><code>declval&lt;T&gt;()</code>看起来是一个函数调用，但因为在<code>decltype</code>下，不会求值，所以假装返回了一个T类型的值（这里的重点只是有个这样的类型）；其后，到函数<code>foo</code>，它看到传给他一些T类型，那我会返回什么类型就由<code>decltype</code>给出。</p><p>使用这种操作符的例子：在编译时检查一个类型是否支持拷贝赋值操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_copy_assignment</span> &#123;<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// SFINAE</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">U</span>,<br>            <span class="hljs-keyword">class</span> = <span class="hljs-keyword">decltype</span>(std::<span class="hljs-built_in">declval</span>&lt;U &amp;&gt;() = std::<span class="hljs-built_in">declval</span>&lt;U <span class="hljs-type">const</span> &amp;&gt;())&gt;<br>  <span class="hljs-type">static</span> true_type <span class="hljs-built_in">try_assignment</span>(U &amp;&amp;);<br>  <span class="hljs-comment">// catch-all overload</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> false_type <span class="hljs-title">try_assignment</span><span class="hljs-params">(...)</span></span>;<br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">try_assignment</span>(std::<span class="hljs-built_in">declval</span>&lt;T&gt;()));<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个例子中判断了能否<code>std::declval&lt;U &amp;&gt;() = std::declval&lt;U const &amp;&gt;()</code>，但也应该判断赋值结果类型是否是<code>T&amp;</code>。</p><p>在没有<code>decltype</code>时，可以使用<code>sizeof</code>也构造出一个<strong>Unevaluated</strong>的场景，但这时<code>type</code>无法由<code>decltype</code>得到，为了得到<code>type</code>，可以让两种函数返回不同大小的值，然后再用<code>sizeof</code>判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义两种返回类型</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">char</span><span class="hljs-params">(&amp;yes)</span>[1]</span>;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">char</span><span class="hljs-params">(&amp;no)</span>[2]</span>;<br><span class="hljs-comment">// 得到返回值的大小</span><br><span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">try_assignment</span>(std::<span class="hljs-built_in">declval</span>&lt;T&gt;()))<br><span class="hljs-comment">// 得到type</span><br><span class="hljs-keyword">typedef</span> bool_constant&lt;<span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">try_assignment</span>(std::<span class="hljs-built_in">declval</span>&lt;T&gt;())) == <span class="hljs-built_in">sizeof</span>(yes)&gt; type;<br></code></pre></td></tr></table></figure><h3 id="void-t"><a href="#void-t" class="headerlink" title="void_t"></a>void_t</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>...&gt;<br><span class="hljs-keyword">using</span> <span class="hljs-type">void_t</span> = <span class="hljs-type">void</span>;<br></code></pre></td></tr></table></figure><p>对于<code>void_t</code>，它是<code>void</code>的别名，但用起来也是一个元函数调用（<code>void_t&lt;int, float, ...&gt;</code>），它接受任意数量的类型参数，给出一个<code>void</code>类型。<br>它无视了所有你给出的参数，然后如同什么都没有一样返回了一个<code>void</code>（就好像直接使用<code>void</code>），但它却可以有奇妙的用处。</p><p>示例：检测一个类中是否有一个类型成员（<code>T::type</code>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// primary</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>, <span class="hljs-keyword">class</span> = <span class="hljs-type">void</span>&gt;<br><span class="hljs-keyword">struct</span> has_type_member : false_type &#123;&#125;;<br><span class="hljs-comment">// specialization</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">has_type_member</span>&lt;T, <span class="hljs-type">void_t</span>&lt;<span class="hljs-keyword">typename</span> T::type&gt;&gt; : true_type &#123;&#125;;<br></code></pre></td></tr></table></figure><p>在该例子中，如果类型中存在类型成员<code>type</code>，那在调用<code>has_type_membe&lt;T&gt;</code>时，会发现特化版本<code>has_type_member&lt;T, void_t&lt;typename T::type&gt;&gt;</code>是合法的，尽管好像是用了一种奇怪的方法来写<code>void</code>，那么它将会被选中。<br>当然，假设不存在，那特化版本不合法，从而转向<code>false_type</code>。</p><p>利用这个<code>void_t</code>可以重写<code>is_copy_assignment</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">using</span> <span class="hljs-type">copy_assignment_t</span> =<br>    <span class="hljs-keyword">decltype</span>(std::<span class="hljs-built_in">declval</span>&lt;T &amp;&gt;() = std::<span class="hljs-built_in">declval</span>&lt;T <span class="hljs-type">const</span> &amp;&gt;());<br><span class="hljs-comment">// primary</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>, <span class="hljs-keyword">class</span> = <span class="hljs-type">void</span>&gt;<br><span class="hljs-keyword">struct</span> is_copy_assignable : false_type &#123;&#125;;<br><span class="hljs-comment">// specialization</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_copy_assignable</span>&lt;T, <span class="hljs-type">void_t</span>&lt;<span class="hljs-type">copy_assignment_t</span>&lt;T&gt;&gt;&gt;<br>    : is_same&lt;<span class="hljs-type">copy_assignment_t</span>&lt;T&gt;, T &amp;&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure><p>而当把<code>&lt;T const &amp;&gt;</code>改为<code>&lt;T &amp;&amp;&gt;</code>，其他不变时，就可以实现<code>is_move_assignable</code>。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>泛型编程是一种在C++中广泛使用的编程范式，它允许程序员编写与数据类型无关的代码。这种编程方式通过使用模板来实现，模板可以是函数模板或类模板。<br>C++ 模板最初是为实现泛型编程设计的，但人们发现模板的能力远远不止于那些设计的功能。一个重要的理论结论就是：C++ 模板是图灵完备的（可以用 C++ 模板模拟图灵机）。<br>理论上说 C++ 模板可以执行任何计算任务，但实际上因为模板是编译期计算，其能力受到具体编译器实现的限制（如递归嵌套深度）。C++ 模板元编程是“意外”功能，而不是设计的功能，这也是 C++ 模板元编程语法丑陋的根源。</p><p>参考：</p><ol><li><a href="https://www.bilibili.com/video/BV1JK4y1D7Yz">现代模板元编程 - Cppcon 2014 - Walter E. Brown</a></li><li><a href="https://www.bilibili.com/video/BV1ui4y1R78s">现代C++进阶：模板元编程与函数式</a></li><li><a href="https://zhuanlan.zhihu.com/p/505887969">关于模板元编程，这是我见过最牛的文章了！</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>c/cpp</tag>
      
      <tag>template</tag>
      
      <tag>TMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用 CMake</title>
    <link href="/2024/12/How_to_use_CMake/"/>
    <url>/2024/12/How_to_use_CMake/</url>
    
    <content type="html"><![CDATA[<h2 id="CMake-配置构建"><a href="#CMake-配置构建" class="headerlink" title="CMake 配置构建"></a>CMake 配置构建</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建 build 文件夹并进行配置(configure)</span><br>cmake -B build<br><span class="hljs-comment"># 根据生成的构建工具进行构建(build)(统一了不同平台的不同构建工具的命令)</span><br>cmake --build build -j4<br><span class="hljs-comment"># 安装(可以类比 make install, 构建 install 目标)</span><br><span class="hljs-built_in">sudo</span> cmake --build build --target install<br></code></pre></td></tr></table></figure><p><img src="/img/How_to_use_CMake/img-How_to_use_CMake.png"></p><h3 id="配置阶段的参数"><a href="#配置阶段的参数" class="headerlink" title="配置阶段的参数"></a>配置阶段的参数</h3><p>-G 指定生成器，<code>CMake</code> 可以生成不同类型的构建系统（比如 <code>Makefile</code> <code>MSBuild</code>，所以可以跨平台）  <code>cmake -B build -G &quot;Unix Makefiles&quot;</code><br><img src="/img/How_to_use_CMake/img-How_to_use_CMake-1.png"></p><p>-D 指定配置变量，配置后会保存在<code>build/CMakeCache.txt</code>中，下次配置仍会保留之前设置的值（删除缓存信息可以只删除<code>CMakeCache.txt</code>而非整个<code>build</code>）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">cmake -B build -DCMAKE_INSTALL_PREFIX=/opt/myapp    <span class="hljs-comment"># 设置安装路径</span><br>cmake -B build -DCMAKE_BUILD_TYPE=Release           <span class="hljs-comment"># 设置构建模式为发布模式</span><br>cmake -B build -DCMAKE_EXPORT_COMPILE_COMMANDS=ON   <span class="hljs-comment"># 设置生成 compile_commands.json 文件</span><br></code></pre></td></tr></table></figure><h2 id="CMake-文件"><a href="#CMake-文件" class="headerlink" title="CMake 文件"></a>CMake 文件</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)<br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="hljs-keyword">OFF</span>)<br><br><span class="hljs-keyword">project</span>(prj LANGUAGES C CXX)<br><br><span class="hljs-keyword">if</span> (PROJECT_BINARY_DIR <span class="hljs-keyword">STREQUAL</span> PROJECT_SOURCE_DIR)<br>    <span class="hljs-keyword">message</span>(WARNING <span class="hljs-string">&quot;The binary directory of CMake cannot be the same as source directory!&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">NOT</span> CMAKE_BUILD_TYPE)<br>    <span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE Release)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">if</span> (WIN32)<br>    <span class="hljs-keyword">add_definitions</span>(-DNOMINMAX -D_USE_MATH_DEFINES)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">NOT</span> MSVC)<br>    <span class="hljs-keyword">find_program</span>(CCACHE_PROGRAM ccache)<br>    <span class="hljs-keyword">if</span> (CCACHE_PROGRAM)<br>        <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Found CCache: $&#123;CCACHE_PROGRAM&#125;&quot;</span>)<br>        <span class="hljs-keyword">set_property</span>(GLOBAL PROPERTY RULE_LAUNCH_COMPILE <span class="hljs-variable">$&#123;CCACHE_PROGRAM&#125;</span>)<br>        <span class="hljs-keyword">set_property</span>(GLOBAL PROPERTY RULE_LAUNCH_LINK <span class="hljs-variable">$&#123;CCACHE_PROGRAM&#125;</span>)<br>    <span class="hljs-keyword">endif</span>()<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><h3 id="生成可执行程序"><a href="#生成可执行程序" class="headerlink" title="生成可执行程序"></a>生成可执行程序</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main main.cpp hello.cpp)<br><br><span class="hljs-comment"># 先指定可执行程序，后添加</span><br><span class="hljs-keyword">add_executable</span>(main)<br><span class="hljs-keyword">target_sources</span>(main PUBLIC main.cpp hello.cpp)<br><br><span class="hljs-comment"># 使用 GLOB 根据扩展名批量查找，替换成 GLOB_RECURSE 则会包含所有子文件夹中的匹配，CONFIGURE_DEPENDS 保证增减文件后自动更新变量</span><br><span class="hljs-keyword">add_executable</span>(main)<br><span class="hljs-keyword">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)<br><span class="hljs-keyword">target_sources</span>(main PUBLIC <span class="hljs-variable">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure><h3 id="生成库"><a href="#生成库" class="headerlink" title="生成库"></a>生成库</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 静态库</span><br><span class="hljs-keyword">add_library</span>(mylib STATIC mylib.cpp)<br><br><span class="hljs-comment"># 动态库</span><br><span class="hljs-keyword">add_library</span>(mylib SHARED mylib.cpp)<br><br><span class="hljs-comment"># OBJ库</span><br><span class="hljs-keyword">add_library</span>(mylib OBJECT mylib.cpp)<br></code></pre></td></tr></table></figure><h3 id="项目配置变量"><a href="#项目配置变量" class="headerlink" title="项目配置变量"></a>项目配置变量</h3><p><code>CMAKE_BUILD_TYPE</code>: 构建类型</p><ul><li><code>Debug</code> 调试模式，生成调试信息</li><li><code>Release</code> 发布模式，优化程度最高</li><li><code>MinSizeRel</code> 最小体积发布，生成的文件比 Release 更小</li><li><code>RelWithDebInfo</code> 带调试信息发布</li></ul><p>与 project 相关的变量 <code>project(helloprj)</code></p><ul><li><code>PROJECT_SOURCE_DIR</code> 若无<code>project</code>，向上一级找，找到最近的调用<code>project</code>的 CMakeLists.txt 所在的源码目录；也就是找到字意的项目目录，<strong>从子模块里直接获得项目最外层目录的路径</strong>。</li><li><code>CMAKE_CURRENT_SOURCE_DIR</code> 当前 CMakeLists.txt 所在的源码目录。</li><li><code>CMAKE_SOURCE_DIR</code> 最外层 CMakeLists.txt 的源码根目录，不建议使用，若项目作为别人的子项目则会直接代表调用项目的根目录。</li><li><code>PROJECT_BINARY_DIR</code> 与<code>PROJECT_SOURCE_DIR</code>对应，是二进制产物路径。</li><li><code>CMAKE_BINARY_DIR</code> 与<code>CMAKE_SOURCE_DIR</code>对应，是二进制产物路径。</li><li><code>PROJECT_NAME</code> 当前项目名</li><li><code>CMAKE_PROJECT_NAME</code> 根项目项目名<br><img src="/img/How_to_use_CMake/img-How_to_use_CMake-2.png"></li></ul><p>C++ 一些要求的配置</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="hljs-keyword">OFF</span>)         <span class="hljs-comment"># 设置是否启用 GCC 特有的功能，关闭以兼容其他编译器</span><br></code></pre></td></tr></table></figure><h3 id="target的相关描述"><a href="#target的相关描述" class="headerlink" title="target的相关描述"></a>target的相关描述</h3><p>target的一些属性也有相应的全局变量，改变全局变量相当于改变了各个属性的初始默认值。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 设置target的属性</span><br><span class="hljs-keyword">add_executable</span>(main main.cpp)<br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> main PROPERTY CXX_STANDARD <span class="hljs-number">17</span>)                                    <span class="hljs-comment"># 设置 C++ 标准</span><br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> main PROPERTY CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)                           <span class="hljs-comment"># 编译器不支持则报错</span><br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> main PROPERTY WIN32_EXECUTABLE <span class="hljs-keyword">ON</span>)                                <span class="hljs-comment"># 在 Windows 系统中，运行时不启动控制台窗口</span><br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> main PROPERTY LINK_WHAT_YOU_USE <span class="hljs-keyword">ON</span>)                               <span class="hljs-comment"># 告诉编译器不要自动剔除没有引用符号的链接库</span><br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> main PROPERTY LIBRARY_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)   <span class="hljs-comment"># 设置动态链接库的输出路径</span><br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> main PROPERTY ARCHIVE_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)   <span class="hljs-comment"># 设置静态链接库的输出路径</span><br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> main PROPERTY RUNTIME_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)   <span class="hljs-comment"># 设置可执行文件的输出路径</span><br><br><span class="hljs-comment"># 批量设置</span><br><span class="hljs-keyword">add_executable</span>(main main.cpp)<br><span class="hljs-keyword">set_target_properties</span>(main PROPERTIES<br>    CXX_STANDARD <span class="hljs-number">17</span>                                     <span class="hljs-comment"># 设置 C++ 标准</span><br>    CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>                            <span class="hljs-comment"># 编译器不支持则报错</span><br>    WIN32_EXECUTABLE <span class="hljs-keyword">ON</span>                                 <span class="hljs-comment"># 在 Windows 系统中，运行时不启动控制台窗口</span><br>    LINK_WHAT_YOU_USE <span class="hljs-keyword">ON</span>                                <span class="hljs-comment"># 告诉编译器不要自动剔除没有引用符号的链接库</span><br>    LIBRARY_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib    <span class="hljs-comment"># 设置动态链接库的输出路径</span><br>    ARCHIVE_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib    <span class="hljs-comment"># 设置静态链接库的输出路径</span><br>    RUNTIME_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin    <span class="hljs-comment"># 设置可执行文件的输出路径</span><br>    )<br><br><span class="hljs-comment"># 设置相应的全局变量</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)                                  <span class="hljs-comment"># 设置 C++ 标准</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)                         <span class="hljs-comment"># 编译器不支持则报错</span><br><span class="hljs-keyword">set</span>(CMAKE_WIN32_EXECUTABLE <span class="hljs-keyword">ON</span>)                              <span class="hljs-comment"># 在 Windows 系统中，运行时不启动控制台窗口</span><br><span class="hljs-keyword">set</span>(CMAKE_LINK_WHAT_YOU_USE <span class="hljs-keyword">ON</span>)                             <span class="hljs-comment"># 告诉编译器不要自动剔除没有引用符号的链接库</span><br><span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib) <span class="hljs-comment"># 设置动态链接库的输出路径</span><br><span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib) <span class="hljs-comment"># 设置静态链接库的输出路径</span><br><span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin) <span class="hljs-comment"># 设置可执行文件的输出路径</span><br><span class="hljs-keyword">add_executable</span>(main main.cpp)<br></code></pre></td></tr></table></figure><p>使用针对target的选项（头文件搜索目录等），避免添加到所有target</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_sources</span>(myapp PUBLIC hello.cpp other.cpp)    <span class="hljs-comment"># 添加源文件 </span><br><span class="hljs-keyword">target_include_directories</span>(myapp PUBLIC <span class="hljs-keyword">include</span>)    <span class="hljs-comment"># 添加头文件搜索目录</span><br><span class="hljs-keyword">target_link_libraries</span>(myapp PUBLIC hellolib)        <span class="hljs-comment"># 添加链接库</span><br>target_add_definitions(myapp PUBLIC -DMY_MACRO=<span class="hljs-number">1</span>)   <span class="hljs-comment"># 添加宏定义 MY_MACRO=1</span><br><span class="hljs-keyword">target_compile_options</span>(myapp PUBLIC -fopenmp)       <span class="hljs-comment"># 添加编译选项</span><br><br><span class="hljs-comment"># 避免使用</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-keyword">include</span>)      <span class="hljs-comment"># 添加头文件搜索目录</span><br><span class="hljs-keyword">link_directories</span>(/opt/cuda)       <span class="hljs-comment"># 添加链接库搜索目录</span><br><span class="hljs-keyword">add_definitions</span>(MY_MACRO=<span class="hljs-number">1</span>)       <span class="hljs-comment"># 添加宏定义 MY_MACRO=1</span><br><span class="hljs-keyword">add_compile_options</span>(-fopenmp)     <span class="hljs-comment"># 添加编译选项</span><br></code></pre></td></tr></table></figure><h3 id="第三方库引入方法"><a href="#第三方库引入方法" class="headerlink" title="第三方库引入方法"></a>第三方库引入方法</h3><h4 id="作为纯头文件引入-target-include-directories"><a href="#作为纯头文件引入-target-include-directories" class="headerlink" title="作为纯头文件引入 target_include_directories"></a>作为纯头文件引入 <code>target_include_directories</code></h4><p>适用于那些只有头文件的库，例如一些轻量级的模板库。这些库不需要编译，因为它们的实现代码都在头文件中，通常是通过模板或者宏等方式实现功能。比如C++的标准模板库就是纯头文件。</p><p>以<code>fmt</code>库为例，该库介绍说明可以通过纯头文件引入，此时只需要项目中的<code>include</code>文件夹。</p><p><img src="/img/How_to_use_CMake/img-How_to_use_CMake-4.png"></p><p>按照要求，在纯头文件引入时需要定义<code>FMT_HEADER_ONLY</code>，此时项目结构如下：</p><p><img src="/img/How_to_use_CMake/img-How_to_use_CMake-5.png"></p><p>在<code>CMakeLists.txt</code>中通过<code>target_include_directories</code>引入第三方库头文件目录。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.30</span>)<br><span class="hljs-keyword">project</span>(prj)<br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">20</span>)<br><br><span class="hljs-keyword">add_executable</span>(prj main.cpp)<br><span class="hljs-keyword">target_include_directories</span>(prj PUBLIC <span class="hljs-keyword">include</span>)<br></code></pre></td></tr></table></figure><p>但是直接引入头文件，函数实现在头文件里，没有提前编译，每次需要重复编译同样的内容，编译时间长。</p><h4 id="作为子模块引入-add-subdirectory"><a href="#作为子模块引入-add-subdirectory" class="headerlink" title="作为子模块引入 add_subdirectory"></a>作为子模块引入 <code>add_subdirectory</code></h4><p>这种方式将第三方库的源代码直接包含到项目中，第三方库通常有自己的<strong>CMakeLists.txt</strong>文件，通过<code>add_subdirectory</code>指令，可以将这个库的构建过程集成到主项目的构建过程中。</p><p>以<code>fmt</code>库为例，这个开源库可以直接将该项目作为用户项目的子项目引入，直接<code>clone</code>源码，目录结构如下：</p><p><img src="/img/How_to_use_CMake/img-How_to_use_CMake-6.png"></p><p>在<code>CMakeLists.txt</code>中通过<code>add_subdirectory</code>引入第三方库的项目子目录，再通过<code>target_link_libraries</code>链接第三方项目库。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.30</span>)<br><span class="hljs-keyword">project</span>(prj)<br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">20</span>)<br><br><span class="hljs-keyword">add_subdirectory</span>(fmt)<br><br><span class="hljs-keyword">add_executable</span>(prj main.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(prj fmt::fmt)<br></code></pre></td></tr></table></figure><h5 id="FetchContent"><a href="#FetchContent" class="headerlink" title="FetchContent"></a>FetchContent</h5><p>FetchContent 是 CMake 的一个模块，可以在配置阶段获取外部依赖库，允许配置步骤使用这些内容进行 <code>add_subdirectory()</code>、<code>include()</code> 或 <code>file()</code> 操作。<br>这与上文所述基本相同，都是直接将第三方项目引入，但通过 FetchContent 可以直接将依赖项目写在 <code>CMakeLists.txt</code> 中，在配置阶段从远程库中下载依赖项目，而无需手动下载。</p><ul><li><strong>FetchContent_Declare</strong></li></ul><p><code>FetchContent_Declare()</code> 函数用于指定如何获取外部项目，比如仓库地址等。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake">FetchContent_Declare(<br>  &lt;name&gt;<br>  &lt;contentOptions&gt;...<br>  [EXCLUDE_FROM_ALL]<br>  [SYSTEM]<br>  [OVERRIDE_FIND_PACKAGE |<br>   FIND_PACKAGE_ARGS args...]<br>)<br></code></pre></td></tr></table></figure><ul><li><strong>FetchContent_MakeAvailable</strong></li></ul><p><code>FetchContent_MakeAvailable</code>命令确保依赖项已经被获取。在获取时，它还会将它们添加到主构建中，以便主构建可以使用这些项目的目标等。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">FetchContent_MakeAvailable(googletest)<br></code></pre></td></tr></table></figure><p>具体使用步骤：</p><ul><li><p>包含<code>FetchContent</code>模块</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">include</span>(FetchContent)<br></code></pre></td></tr></table></figure></li><li><p>声明外部项目</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake">FetchContent_Declare(<br>  fmt<br>  GIT_REPOSITORY https://github.com/fmtlib/fmt.git<br>  GIT_TAG <span class="hljs-number">11.1</span>.<span class="hljs-number">1</span><br>)<br></code></pre></td></tr></table></figure><p>这一步声明了一个外部项目<code>fmt</code>，并指定了其下载和配置的详细信息（此时并不会立即下载或配置项目）。</p></li><li><p>确保外部项目可用</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">FetchContent_MakeAvailable(fmt)<br></code></pre></td></tr></table></figure><p>这一步确保声明的外部项目<code>fmt</code>已经被下载、配置、构建，并且可以使用。</p></li><li><p>链接第三方库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_link_libraries</span>(prj PRIVATE fmt::fmt)<br></code></pre></td></tr></table></figure><p>这一步使用 target_link_libraries 将第三方库 fmt 链接到项目中。</p></li></ul><p>使用该种途径时，项目如下，可以发现<strong>build</strong>文件夹中的<code>_deps</code>文件夹存放了获取的第三方项目，在<code>main.cpp</code>中可以直接使用。 </p><p><img src="/img/How_to_use_CMake/img-How_to_use_CMake-8.png"></p><p>在<code>CMakeLists.txt</code>中通过<code>FetchContent</code>引入第三方项目，再通过<code>target_link_libraries</code>链接第三方项目库。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.30</span>)<br><span class="hljs-keyword">project</span>(prj)<br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">20</span>)<br><br><span class="hljs-keyword">include</span>(FetchContent)<br>FetchContent_Declare(fmt<br>        GIT_REPOSITORY https://github.com/fmtlib/fmt.git<br>        GIT_TAG <span class="hljs-number">11.1</span>.<span class="hljs-number">1</span>)<br>FetchContent_MakeAvailable(fmt)<br><br><span class="hljs-keyword">add_executable</span>(prj main.cpp)<br><br><span class="hljs-keyword">target_link_libraries</span>(prj PUBLIC fmt::fmt)<br></code></pre></td></tr></table></figure><h4 id="引用系统中安装的第三方库-find-package"><a href="#引用系统中安装的第三方库-find-package" class="headerlink" title="引用系统中安装的第三方库 find_package"></a>引用系统中安装的第三方库 <code>find_package</code></h4><p>在存在菱形依赖的情况下，即项目A依赖于B和C，而B和C又同时依赖于D，使用子模块引用（<code>add_subdirectory</code>），可能会导致D被定义两遍，从而引发错误。<br>而通过<code>find_package</code>使用系统预安装的库则可以有效避免这个问题。当使用<code>find_package</code>查找库时，CMake会记录已经找到的库。因此，即使多个模块依赖同一个库，<code>find_package</code>也只会引入一次。例如，当找到库B和D时，再找C时不会将D重复引入。</p><p>不同操作系统可以通过各自的包管理器来安装所需的库。以Ubuntu为例，可以使用<code>apt</code>包管理器来安装库。比如安装<code>fmt</code>库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> apt install libfmt-dev<br></code></pre></td></tr></table></figure><p>此时由于头文件等已经在系统查找路径中（比如<code>/usr/include</code>），可以直接在文件中导入相关的头文件，此时，项目结构如下：</p><p><img src="/img/How_to_use_CMake/img-How_to_use_CMake-7.png"></p><p>在<code>CMakeLists.txt</code>中则需要先<code>find_package</code>找到<code>fmt</code>包，再通过<code>target_link_libraries</code>链接第三方项目库。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.30</span>)<br><span class="hljs-keyword">project</span>(prj)<br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">20</span>)<br><br><span class="hljs-keyword">find_package</span>(fmt)<br><br><span class="hljs-keyword">add_executable</span>(prj main.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(prj fmt::fmt)<br></code></pre></td></tr></table></figure><p>在CMake中，一个项目可以包含多个库。CMake允许一个包（package）提供多个库，这些库也被称为组件（components）。因此，在使用<code>target_link_libraries</code>指令链接库时，应采用<code>包名::组件名</code>的格式。<br>例如，在上文中提到的<code>fmt::fmt</code>，其中<code>fmt</code>是包名，第二个<code>fmt</code>是该包提供的一个组件名。再比如，TBB这个包，就包含了<code>tbb</code>、<code>tbbmalloc</code>和<code>tbbmalloc_proxy</code>这三个组件。当需要链接这些组件时，可以分别使用<code>TBB::tbb</code>、<code>TBB::tbbmalloc</code>和<code>TBB::tbbmalloc_proxy</code>。</p><p><code>find_package</code>时可以指定必要的组件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">find_package</span>(TBB REQUIRED COMPONENTS tbb tbbmalloc REQUIRED)<br><span class="hljs-keyword">target_link_libraries</span>(myexec PUBLIC TBB::tbb TBB::tbbmalloc)<br></code></pre></td></tr></table></figure><h2 id="CMake-项目结构"><a href="#CMake-项目结构" class="headerlink" title="CMake 项目结构"></a>CMake 项目结构</h2><p>一个典型的 C++ 项目可以采用以下结构：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sh">prj<br>├── CMakeLists.txt<br>├── cmake<br>│   └── MyFuncs.cmake<br>├── subprj1<br>│   ├── CMakeLists.txt<br>│   ├── include<br>│   │   └── subprj1<br>│   │       └── Animal.h<br>│   └── src<br>│       └── Animal.cpp<br>├── ...<br>└── mainprj<br>    ├── CMakeLists.txt<br>    ├── include<br>    │   └── mainprj<br>    │       └── utils.h<br>    └── src<br>        └── main.cpp<br></code></pre></td></tr></table></figure><p>在这个结构中，项目根目录包含了一个 <code>CMakeLists.txt</code> 文件以及多个子项目文件夹。<br>一个子项目作为可执行文件，负责与用户交互，其他子项目则作为不同的库文件，编写实际的业务逻辑。可执行文件仅作为入口，所有的功能实现都在库文件中，这样的分离使得代码逻辑的库也能被其他软件组合和复用。<br>另外，根项目还可能包含其他文件夹，比如上面的<code>cmake</code>文件夹用于存放<code>CMake</code>配置脚本或工具函数。</p><p>每个子项目的组织格式为：</p><ul><li><code>subprj/CMakeLists.txt</code></li><li><code>subprj/include/subprj/module.h</code></li><li><code>subprj/src/module.cpp</code></li></ul><h3 id="根项目-CMakeLists-txt"><a href="#根项目-CMakeLists-txt" class="headerlink" title="根项目 CMakeLists.txt"></a>根项目 <code>CMakeLists.txt</code></h3><p>在根项目中的 <code>CMakeLists.txt</code> 中，我们进行基本的 C++ 版本设置等选项，并使用 <code>project</code> 命令初始化项目。<br>之后，通过 <code>add_subdirectory</code> 将子项目逐一添加到根项目中，这样根项目就能够调用子项目中的 <code>CMakeLists.txt</code> 文件。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.30</span>)<br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">20</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="hljs-keyword">OFF</span>)<br><span class="hljs-keyword">set</span>(CMAKE_MODULE_PATH <span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/cmake;$&#123;CMAKE_MODULE_PATH&#125;&quot;</span>)<br><br><span class="hljs-keyword">project</span>(prj LANGUAGES CXX)<br><br><span class="hljs-keyword">include</span>(MyFuncs)<br><br><span class="hljs-keyword">add_subdirectory</span>(subprj1)<br><span class="hljs-keyword">add_subdirectory</span>(mainprj)<br></code></pre></td></tr></table></figure><h3 id="子项目-CMakeLists-txt"><a href="#子项目-CMakeLists-txt" class="headerlink" title="子项目 CMakeLists.txt"></a>子项目 <code>CMakeLists.txt</code></h3><p>根项目的 <code>CMakeLists.txt</code> 主要负责全局配置，而子项目中的 <code>CMakeLists.txt</code> 则只关注该子项目自身的设置，如头文件目录、需要链接的库等。</p><p>子项目中，通常会使用 <code>add_library</code> 或 <code>add_executable</code> 来生成<code>target</code>，并配置<code>target</code>的选项，如链接的库和包含的头文件等。<br>在链接库时，由于 <code>PUBLIC</code> 的传播作用，某项目链接了其他项目的库后，也可以自动包含相应的头文件。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp <span class="hljs-keyword">include</span>/*.h)<br><span class="hljs-keyword">add_executable</span>(mainprj <span class="hljs-variable">$&#123;srcs&#125;</span>)<br><span class="hljs-keyword">target_include_directories</span>(mainprj PUBLIC <span class="hljs-keyword">include</span>)<br><span class="hljs-keyword">target_link_libraries</span>(mainprj PUBLIC subprj1)<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>mainprj</code> 是一个可执行子项目，它通过 <code>add_executable</code> 生成可执行文件，并链接了其他子项目 <code>subprj1</code>。<br>在子项目中，可以使用<code>GLOB_RECRUSE</code>来获取文件夹中所有的<code>.h</code>文件和<code>.cpp</code>文件，只是编译的话只需要<code>.cpp</code>文件，将<code>.h</code>也写出可以使头文件也被纳入IDE的项目资源浏览器，比如在头文件中引用头文件也可以使用<code>&lt;&gt;</code>写法搜索得到。</p><p>在上面的例子中，<code>mainprj</code> 是一个可执行子项目，它通过 <code>add_executable</code> 生成可执行文件，并链接了其他子项目 <code>subprj1</code>。</p><p>在子项目中，可以使用 <code>GLOB_RECURSE</code> 来获取文件夹中所有的 <code>.cpp</code> 文件和 <code>.h</code> 文件。虽然编译时只需要 <code>.cpp</code> 文件，但将 <code>.h</code> 文件也一并列出可以使头文件被纳入 IDE 的项目资源浏览器。比如在头文件中引用其他头文件时，也可以使用 <code>&lt;&gt;</code> 写法，可以直接跳转到目标头文件。</p><h3 id="子项目头文件"><a href="#子项目头文件" class="headerlink" title="子项目头文件"></a>子项目头文件</h3><p>子项目头文件的例子如下，每个头文件使用<code>#pragma once</code>，防止重复导入；之后将代码使用<code>namespace subprj&#123;&#125;</code>包裹，这样如果两个子库有相同标识符在使用时也不会出现冲突。</p><p>如果没有<code>#pragma once</code>，在头文件中定义了一个类，在实现文件中重复导入两次则会造成重复定义的编译错误，<code>#pragma once</code>可以保证一个编译单元中不会因为某个头文件出现重复定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//  如果下面的头文件没有防重复导入，则会出现错误</span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;subprj1/Animal.h&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;subprj1/Animal.h&gt;</span></span><br></code></pre></td></tr></table></figure><p>而如果没有<code>namespace</code>，我在两个子库中都一个同名的类，如果某个文件同时导入这两个头文件，也会有重复定义的编译错误；<br>如果有相同的函数名，引入两个头文件，编译该单元时没有错误，但要链接时无法确定是哪一个函数实现，出现链接错误。<br>所以将每个子项目使用不同的<code>namespace</code>先进行包裹，“把自己先圈起来”，防止和未知的头文件或库发生冲突，<code>namespace</code>相当于延长了标识符，人为地划定模块，防止标识符冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 虽然是不同的头文件，但有相同的类标识符，一起复制过来的话就会重复定义，使用namespace即可隔离</span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&quot;subprj1/example.h&quot;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&quot;subprj2/example.h&quot;</span></span><br></code></pre></td></tr></table></figure><p>另外，如果要在头文件中写函数定义，需要使用<code>inline</code>或<code>static</code>修饰，它们可以使函数定义限制在该编译单元里，防止不同项目都引入函数定义后，链接时出现重复定义。<br>虽然在头文件中会有<code>namespace</code>，但解决不了这个问题，因为每个导入该头文件的都是原封不动的将头文件复制过来，相当于这个函数的全名（<code>namespace::func</code>）在多个文件里都被编译了一遍，那多个编译单元链接时，这个函数名字还是有多个意思（定义），从而造成冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 如果没有修饰，两个cpp编译后进行链接时，utils中的函数就会有多个定义造成冲突</span><br><span class="hljs-comment">// a.cpp</span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;subprj1/utils.h&gt;</span></span><br><span class="hljs-comment">// b.cpp</span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;subprj1/utils.h&gt;</span></span><br></code></pre></td></tr></table></figure><p>从上面可以总结的是：在同一个编译单元中，可以有同名的声明（函数声明、类声明、变量声明），但定义都只能有一个（多次导入同一头文件造成的类冲突；导入不同头文件造成的类冲突）。<br>在多个编译单元中，依旧可以有同名的声明，复制于同一个头文件的不同编译单元的类定义是可行的（每个编译单元中会有自己的类副本），但函数定义和变量定义不行，但函数和变量的定义只能有一个副本（使用<code>static</code>和<code>inline</code>）。</p><p>一个典型的头文件如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// prj/subprj1/include/subprj1/Animal.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-keyword">namespace</span> subprj1 &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Animal</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">final</span> : Animal &#123;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">final</span> : Animal &#123;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="子项目源文件"><a href="#子项目源文件" class="headerlink" title="子项目源文件"></a>子项目源文件</h3><p>一般源文件和相应的头文件成对出现，在源文件中，<code>include</code>相应的头文件，并在<code>namespace</code>中进行头文件的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// prj/subprj1/src/Animal.cpp</span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;subprj1/Animal.h&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> subprj1 &#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Cat::speak</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Cat::speak&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::speak</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Dog::speak&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个cpp文件是一个编译单元，一般在写新功能时，会新建一对头文件和源文件，视为一个模块。<br>上面提到的<code>namespace</code>可以为每个模块搞成一块命名空间，但一般将每个子项目作为分隔不同命名空间的尺度就可以，项目内需要人为的保证每个小模块不会发生重复定义。</p><p>如果一个模块的头文件中仅仅声明了其他模块中的类，而<strong>没有直接使用或解引用该类的成员</strong>（例如调用成员函数或访问成员变量），那么头文件中不需要包含该类对应的头文件，而只需提供一个前向声明。例如，可以使用 struct ClassName; 或 class ClassName; 来声明类。只有在实际需要使用该类成员的实现文件（如 .cpp 文件）中，才需要包含完整的头文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Animal类在其他头文件定义，但该头文件中无需引用</span><br><span class="hljs-comment">// 我们只需要声明一下Animal是一个`struct`而不是一个函数之类的，因为此处并没有解引用Animal类</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-keyword">namespace</span> subprj1 &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Animal</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Another</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">use</span><span class="hljs-params">(Animal *a)</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="cmake-文件夹"><a href="#cmake-文件夹" class="headerlink" title="cmake&#x2F; 文件夹"></a>cmake&#x2F; 文件夹</h3><p>与 C&#x2F;C++ 中的 <code>#include</code> 类似，CMake 也有一个 <code>include</code> 命令。使用 <code>include(XXX)</code> 时，CMake 会在 <code>CMAKE_MODULE_PATH</code> 列表中的所有路径下查找名为 <code>XXX.cmake</code> 的文件。<br>通过这种方式，可以将一些常用的函数、宏或变量写在独立的 <code>XXX.cmake</code> 文件中，存放在项目的 <code>cmake/</code> 文件夹中。然后在需要使用这些功能的地方，通过 <code>include</code> 引入相应的 <code>.cmake</code> 文件，从而实现代码的复用和模块化管理。 </p><p>前面的根项目<code>CMakeLists.txt</code>中，以下部分就是设置<code>CMAKE_MODULE_PATH</code>以及<code>include</code>相应的<code>.cmake</code>。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(CMAKE_MODULE_PATH <span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/cmake;$&#123;CMAKE_MODULE_PATH&#125;&quot;</span>)<br><span class="hljs-keyword">include</span>(MyFuncs)<br></code></pre></td></tr></table></figure><p>比如说在<code>.cmake</code>文件中写一些常用的函数或宏等：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 用法：my_add_target(prj EXECUTABLE)</span><br><span class="hljs-comment"># 通过该宏可以直接简化子项目生成target的CMake代码</span><br><span class="hljs-keyword">macro</span> (my_add_target name type)<br>    <span class="hljs-keyword">file</span>(GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp src/*.h)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;$&#123;type&#125;&quot;</span> <span class="hljs-keyword">MATCHES</span> <span class="hljs-string">&quot;EXECUTABLE&quot;</span>)<br>        <span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;name&#125;</span> <span class="hljs-variable">$&#123;srcs&#125;</span>)<br>    <span class="hljs-keyword">else</span>()<br>        <span class="hljs-keyword">add_library</span>(<span class="hljs-variable">$&#123;name&#125;</span> <span class="hljs-variable">$&#123;type&#125;</span> <span class="hljs-variable">$&#123;srcs&#125;</span>)<br>    <span class="hljs-keyword">endif</span>()<br>    <span class="hljs-keyword">target_include_directories</span>(<span class="hljs-variable">$&#123;name&#125;</span> PUBLIC <span class="hljs-keyword">include</span>)<br><span class="hljs-keyword">endmacro</span>()<br></code></pre></td></tr></table></figure><p><strong>macro 和 function</strong>：</p><ul><li>**<code>macro</code>**：相当于将代码直接粘贴到调用者的位置。</li><li>**<code>function</code>**：创建了一个闭包，它优先访问定义者的作用域。</li></ul><p><strong>include 和 add_subdirectory</strong></p><ul><li>**<code>include</code>**：相当于将代码直接粘贴到调用者的作用域中。</li><li>**<code>add_subdirectory</code>**：会在子目录中创建一个新的作用域。</li></ul><p>可以类比 C++ 中的<code>#define</code>和函数。</p><p>参考：</p><ol><li><a href="https://www.bilibili.com/video/BV16P4y1g7MH">小彭老师的并行课</a></li><li><a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">CMake Tutorial</a></li><li><a href="https://cmake.org/cmake/help/latest/module/FetchContent.html">FetchContent</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>cmake</tag>
      
      <tag>Makefile</tag>
      
      <tag>c/cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode插件配置</title>
    <link href="/2024/11/VSCode-Extension/"/>
    <url>/2024/11/VSCode-Extension/</url>
    
    <content type="html"><![CDATA[<p><code>VSCode</code> 本身只是一个编辑器，但许多丰富的插件拓展使它可以进行许多语言的开发。不过插件一般都需要个性化配置，以前对于插件的使用都是网页直接搜他人写的教程，没有真的自己去捣鼓如何用好一个插件，本文以 <code>clangd</code> 插件为例，来说明面对一个插件应当如何去使用它。</p><h2 id="VSCode-设置界面"><a href="#VSCode-设置界面" class="headerlink" title="VSCode 设置界面"></a>VSCode 设置界面</h2><p><img src="/img/VSCode-Extension/img-VSCode-Extension.png"></p><p><code>VSCode</code> 的插件配置页面位于其设置界面，这里不仅包含了编辑器和窗口等常规设置项，还涵盖了各种插件的个性化设置。用户可以通过命令面板访问设置文件，直接编辑设置文件的方式进行配置。</p><p><img src="/img/VSCode-Extension/img-VSCode-Extension-1.png"></p><p>设置文件分为 <code>User</code> 和 <code>Workspace</code> 两种作用域，其中，前者位于用户目录（<code>~/.config/Code/User/settings.json</code>）下，后者位于该工作目录即当前打开的文件夹或工作区（<code>&#123;workspace&#125;/.vscode/settings.json</code>）中。</p><p>在进行个性化设置时，用户可以通过命令面板打开默认设置进行对比。</p><h2 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h2><p>以<code>clangd</code>为例，这是一个由llvm项目推出的C++语言服务器，它通过LSP（Language Server Protocol）协议向编辑器提供语法补全、错误检测、跳转、格式化等功能。</p><p>用户可以直接在 <code>VSCode</code> 的应用商店下载 <code>clangd</code> 插件。安装后，插件会提示用户需要安装 <code>clangd</code> 包。这是因为 <code>VSCode</code> 插件通常是基于电脑上已有的软件包进行适配，使其能够在 <code>VSCode</code> 中发挥作用。软件包的路径也是使用插件时需要填写的配置之一。</p><p><img src="/img/VSCode-Extension/img-VSCode-Extension-2.png"></p><p>如果错过了插件安装后的提示，用户可以通过命令面板来下载<code>clangd</code>，如下图，除了新的可配置项，下载完一个插件后也会产生很多与该插件相关的命令项。</p><p><img src="/img/VSCode-Extension/img-VSCode-Extension-3.png"></p><p>在插件的信息页面中，用户可以在<code>FEATURES</code>栏找到有关该插件的特征信息，包括命令与可配置项的信息。</p><p><img src="/img/VSCode-Extension/img-VSCode-Extension-4.png"></p><p>通过这个页面，用户可以了解到<code>clangd</code>的各种配置项的描述与默认值，进而进行配置。另一种途径是找到该插件的开源项目，其中<code>package.json</code>文件中的<code>contributes.configuration</code>部分包含了插件配置项的定义。</p><p>注意到上图中的 <code>clangd.arguments</code> 配置项，该数组用来作为 <code>clangd</code> 服务运行的参数，想要在该地方填写，则需要学习 <code>clangd</code> 本身有哪些运行参数，可以通过运行 <code>clangd --help</code> 或 <code>clangd --help-list-hidden</code> 命令来查看所有可用的命令行参数，包括默认值；或者直接前往 <a href="https://clangd.llvm.org/"> <code>clangd</code> 官网</a>学习。配置插件时为了填写软件包相关的参数，需要脱离 <code>VSCode</code> 插件本身，前往软件包的领域去寻找。</p><p>上图中的 <code>clangd.fallbackFlags</code> 配置项，则是用于指定当没有找到编译数据库（<code>compile_commands.json</code>）时，用于解析文件的额外 clang 编译标志。<code>compile_commands.json</code> 文件一般会包含项目文件之间关联信息，我们也可以通过该配置项手动声明一些标志（比如 <code>-Ixxx</code> 指定头文件搜索路径）。</p><p>对于在 <code>VSCode</code> 中配置使用 <code>clangd</code>，我们会涉及许多文件，其中既有与插件相关的，又有与 <code>clangd</code> 本身相关的：</p><ul><li>插件配置文件：<code>settings.json</code> （全局用户和工作区）</li><li><code>clangd</code> 配置文件：<code>~/.config/clangd/config.yaml</code> （user configuration）和 <code>.clangd</code>（project configuration）。</li><li><code>compile_commands.json</code></li><li>…</li></ul><p>不同的插件配置时会有不同的配置项，但关键在于如何找到配置项、理解配置项，并熟悉整个配置流程。</p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>登录账号后，可以同步备份 <code>VSCode</code> 上的个性化配置，可以在新设备上无痛迁移之前的插件以及相关配置的信息。</p><p><img src="/img/VSCode-Extension/img-VSCode-Extension-5.png"></p><p><img src="/img/VSCode-Extension/img-VSCode-Extension-6.png"></p><p>参考：</p><ol><li><a href="https://clangd.llvm.org/">clangd 官网</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MSVC，GCC，Clang——不同C/C++编译器对比</title>
    <link href="/2024/10/MSVC-GCC-Clang/"/>
    <url>/2024/10/MSVC-GCC-Clang/</url>
    
    <content type="html"><![CDATA[<p>在线的 C&#x2F;CPP 编译器：<a href="https://godbolt.org/">Compiler Explorer (godbolt.org)</a></p><p>20 世纪 50 年代，计算机程序主要使用汇编语言开发，这对开发者来说太难了。IBM 也希望销售更多计算机让人们编程，<em>John Backus</em> 针对汇编语言的缺点着手研究开发 <strong>Fortran</strong> 语言，科学家们希望利用高级语言编写程序，但同时提供接近手动调整的机器代码的性能，在 1957 年，首个编译器 IBM Fortran 诞生了。</p><h1 id="MSVC"><a href="#MSVC" class="headerlink" title="MSVC"></a>MSVC</h1><p>MSVC（Microsoft Visual C++）是微软公司的 C++开发工具，具有集成开发环境，可提供编辑 C 语言，C++以及 C++&#x2F;CLI 等编程语言。</p><p>VC++集成了便利的调试工具，特别是集成了微软 Windows 操作系统应用程序接口（Windows API）、三维动画 DirectX API，微软. NET 框架。</p><h1 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h1><p>GCC（GNU Compiler Collection）是由 GNU 项目开发的一套优化编译器，它支持多种编程语言、操作系统和计算机架构。作为自由软件，GCC 由自由软件基金会（FSF）在 GNU 通用公共许可证（GNU GPL）下分发。</p><p>GCC 最初名为 GNU C 编译器（GNU C Compiler），因为它最初只支持 C 语言。然而，不久之后，GCC 就扩展了对 C++ 的支持，并逐渐增加了对 Fortran、Pascal、Objective-C、Java、Ada、Go 等多种语言的支持。</p><p>GCC 不仅是 GNU 操作系统的官方编译器，也是许多类 UNIX 系统和 Linux 发行版的标准编译器。在 GCC 出现之后，BSD 家族的大部分操作系统也开始使用 GCC。不过，一些系统如 FreeBSD、OpenBSD 和 Apple 的 macOS 已经转而使用 Clang 编译器。</p><p>MinGW（Minimalist GNU for Windows）是将 GCC 编译器和 GNU Binutils 移植到 Windows 32位平台的项目。它包括了一系列头文件（用于 Win 32 API）、库和可执行文件。由于最初的 MinGW 项目更新缓慢，且不支持64位环境开发，OneVision Software 于2005年开始开发 MinGW-w64。MinGW-w64 支持 GCC 所支持的大多数编程语言，包括 C、C++、Objective-C、Objective-C++、Fortran 和 Ada。</p><p>GCC 实践：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># hello.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HELLO <span class="hljs-string">&quot;hello\n&quot;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-built_in">printf</span>(HELLO);<br>&#125;<br></code></pre></td></tr></table></figure><p>预处理生成.i 文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">gcc -E hello.c -o hello.i<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># hello.i</span><br>...<br>...<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>将预处理的文件转换为特定的汇编文件。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">gcc</span> -S hello.i -o hello.s<br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">.file</span><span class="hljs-string">&quot;hello.c&quot;</span><br><span class="hljs-string">.text</span><br><span class="hljs-string">.section</span><span class="hljs-string">.rodata</span><br><span class="hljs-string">.LC0</span>:<br><span class="hljs-string">.string</span><span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-string">.text</span><br><span class="hljs-string">.globl</span>main<br><span class="hljs-string">.type</span>main, @function<br>main:<br><span class="hljs-string">.LFB0</span>:<br><span class="hljs-string">.cfi_startproc</span><br>endbr64<br>pushq%rbp<br><span class="hljs-string">.cfi_def_cfa_offset</span> 16<br><span class="hljs-string">.cfi_offset</span> 6, -16<br>movq%rsp, %rbp<br><span class="hljs-string">.cfi_def_cfa_register</span> 6<br>leaq<span class="hljs-string">.LC0</span><span class="hljs-params">(%rip)</span>, %rax<br>movq%rax, %rdi<br>callputs@PLT<br>movl$0, %eax<br>popq%rbp<br><span class="hljs-string">.cfi_def_cfa</span> 7, 8<br>ret<br><span class="hljs-string">.cfi_endproc</span><br><span class="hljs-string">.LFE0</span>:<br><span class="hljs-string">.size</span>main, <span class="hljs-string">.-main</span><br><span class="hljs-string">.ident</span><span class="hljs-string">&quot;GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0&quot;</span><br><span class="hljs-string">.section</span><span class="hljs-string">.note.GNU-stack</span>,<span class="hljs-string">&quot;&quot;</span>,@progbits<br><span class="hljs-string">.section</span><span class="hljs-string">.note.gnu.property</span>,<span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-string">.align</span> 8<br><span class="hljs-string">.long</span>1f - 0f<br><span class="hljs-string">.long</span>4f - 1f<br><span class="hljs-string">.long</span>5<br>0:<br><span class="hljs-string">.string</span><span class="hljs-string">&quot;GNU&quot;</span><br>1:<br><span class="hljs-string">.align</span> 8<br><span class="hljs-string">.long</span>0xc0000002<br><span class="hljs-string">.long</span>3f - 2f<br>2:<br><span class="hljs-string">.long</span>0x3<br>3:<br><span class="hljs-string">.align</span> 8<br>4:<br></code></pre></td></tr></table></figure><p>将汇编代码转换为机器指令，由汇编器完成。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">gcc -c hello.c -o hello.o<br></code></pre></td></tr></table></figure><p>链接。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">gcc -o hello.o -o hello<br></code></pre></td></tr></table></figure><h1 id="Clang"><a href="#Clang" class="headerlink" title="Clang"></a>Clang</h1><p>Clang 是一个<strong>编译器前端</strong>，支持多种编程语言，包括 C、C++、Objective-C、Objective-C++，以及支持 OpenMP、OpenCL、RenderScript、CUDA、SYCL 和 HIP 等软件框架。它可以作为 GNU 编译器集合（GCC）的替代品，并且兼容 GCC 的大多数编译标志和非官方的语言扩展。Clang 使用 LLVM 作为其编译器的后端。</p><p>LLVM 是<strong>一套编译器和工具链技术</strong>，它允许开发者为任何编程语言创建前端，为任何指令集架构创建后端。LLVM 的设计核心是一种与语言无关的中间表示（<strong>IR</strong>），这种 IR 可以看作是一种可移植的高级汇编语言，它可以通过多次转换来进行优化。LLVM 项目始于 2000 年，在伊利诺伊大学厄巴纳-香槟分校由 Vikram Adve 和 Chris Lattner 领导。最初，LLVM 是作为研究静态和动态编程语言动态编译技术的研究基础设施而开发的。</p><p>2005 年，苹果公司聘请了 Chris Lattner 并组建了一个团队，致力于将 LLVM 系统应用于苹果开发系统中的多种用途。最初，LLVM 项目计划使用 GCC 作为前端，但由于 GCC 源代码庞大且实现复杂，加之苹果的软件大量使用 Objective-C，而 GCC 对 Objective-C 的支持优先级不高，以及 GCC 的 GNU 通用公共许可证（GPL）第 3 版要求分发 GCC 扩展或修改版本的开发者必须提供源代码，这与 LLVM 的宽松许可证不符。因此，苹果公司开发了 Clang，自 Xcode 4 起，苹果的默认编译器改为了 Clang&#x2F;LLVM。</p><p>Clang&#x2F;LLVM 实践：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># hello.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HELLO <span class="hljs-string">&quot;hello\n&quot;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-built_in">printf</span>(HELLO);<br>&#125;<br></code></pre></td></tr></table></figure><p>预处理生成.i 文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">clang -E -c ./hello.c -o ./hello.i<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># hello.i</span><br>...<br>...<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>将.i 文件转化为.bc 文件，这是 LLVM 位代码（bitcode）文件，是中间表示形式，可供进一步优化和转换。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">clang -emit-llvm ./hello.i -c -o ./hello.bc<br></code></pre></td></tr></table></figure><p>将.c 文件编译成 LLVM 中间表示的汇编代码文件.ll，人类可读的中间表示形式。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">clang -emit-llvm ./hello.c -S -o ./hello.ll<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ll">; ModuleID = &#x27;./hello.c&#x27;<br>source_filename = &quot;./hello.c&quot;<br>target datalayout = &quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;<br>target triple = &quot;x86_64-pc-linux-gnu&quot;<br><br>@.str = private unnamed_addr constant [7 x i8] c&quot;hello\0A\00&quot;, align 1<br><br>; Function Attrs: noinline nounwind optnone uwtable<br>define dso_local i32 @main() #0 &#123;<br>  %1 = call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0))<br>  ret i32 0<br>&#125;<br><br>declare i32 @printf(i8* noundef, ...) #1<br><br>attributes #0 = &#123; noinline nounwind optnone uwtable &quot;frame-pointer&quot;=&quot;all&quot; &quot;min-legal-vector-width&quot;=&quot;0&quot; &quot;no-trapping-math&quot;=&quot;true&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;=&quot;generic&quot; &#125;<br>attributes #1 = &#123; &quot;frame-pointer&quot;=&quot;all&quot; &quot;no-trapping-math&quot;=&quot;true&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;=&quot;generic&quot; &#125;<br><br>!llvm.module.flags = !&#123;!0, !1, !2, !3, !4&#125;<br>!llvm.ident = !&#123;!5&#125;<br><br>!0 = !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125;<br>!1 = !&#123;i32 7, !&quot;PIC Level&quot;, i32 2&#125;<br>!2 = !&#123;i32 7, !&quot;PIE Level&quot;, i32 2&#125;<br>!3 = !&#123;i32 7, !&quot;uwtable&quot;, i32 1&#125;<br>!4 = !&#123;i32 7, !&quot;frame-pointer&quot;, i32 2&#125;<br>!5 = !&#123;!&quot;Ubuntu clang version 14.0.0-1ubuntu1.1&quot;&#125;<br></code></pre></td></tr></table></figure><p>使用 llc 将中间表示文件（.bc 或 .ll）转换为目标平台的汇编代码。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 这两种转换生成的汇编代码相同</span><br>llc ./hello.ll -o ./hello.s<br>llc ./hello.bc -o ./hello.s<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text<br>.file&quot;hello.c&quot;<br>.globlmain                            # -- Begin function main<br>.p2align4, 0x90<br>.typemain,@function<br>main:                                   # @main<br>.cfi_startproc<br># %bb.0:<br>pushq%rbp<br>.cfi_def_cfa_offset 16<br>.cfi_offset %rbp, -16<br>movq%rsp, %rbp<br>.cfi_def_cfa_register %rbp<br>movabsq$.L.str, %rdi<br>movb$0, %al<br>callqprintf@PLT<br>xorl%eax, %eax<br>popq%rbp<br>.cfi_def_cfa %rsp, 8<br>retq<br>.Lfunc_end0:<br>.sizemain, .Lfunc_end0-main<br>.cfi_endproc<br>                                        # -- End function<br>.type.L.str,@object                  # @.str<br>.section.rodata.str1.1,&quot;aMS&quot;,@progbits,1<br>.L.str:<br>.asciz&quot;hello\n&quot;<br>.size.L.str, 7<br><br>.ident&quot;Ubuntu clang version 14.0.0-1ubuntu1.1&quot;<br>.section&quot;.note.GNU-stack&quot;,&quot;&quot;,@progbits<br></code></pre></td></tr></table></figure><p>转变为可执行的二进制文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">clang ./hello.s -o hello<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center"></th><th align="center">MSVC</th><th align="center">GCC</th><th align="center">Clang&#x2F;LLVM</th></tr></thead><tbody><tr><td align="center">开源协议</td><td align="center"></td><td align="center">GNU GPL</td><td align="center">Apache 2.0</td></tr><tr><td align="center">支持平台</td><td align="center">Windows</td><td align="center">UNIX、Windows、Mac</td><td align="center">Unix、Mac</td></tr><tr><td align="center">构建工具</td><td align="center"></td><td align="center">Make</td><td align="center">CMake</td></tr><tr><td align="center">链接器</td><td align="center"></td><td align="center">ld</td><td align="center">lld</td></tr><tr><td align="center">调试器</td><td align="center"></td><td align="center">GDB</td><td align="center">LLDB</td></tr></tbody></table><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzI4OTc4MzI5OA==&mid=2247520367&idx=1&sn=cdbcd59112b4867f9c4eb853bb150af5&source=41#wechat_redirect">编译器的「五个十年」发展史</a></li><li><a href="https://en.wikipedia.org/">维基百科</a></li><li><a href="https://github.com/chenzomi12/AISystem">chenzomi12&#x2F;AISystem: AISystem 主要是指AI系统，包括AI芯片、AI编译器、AI推理和训练框架等AI全栈底层技术 (github.com)</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>MSVC</tag>
      
      <tag>Clang</tag>
      
      <tag>GCC</tag>
      
      <tag>LLVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开源贡献的一些规范</title>
    <link href="/2024/09/Open-Source/"/>
    <url>/2024/09/Open-Source/</url>
    
    <content type="html"><![CDATA[<h1 id="一、PR流程"><a href="#一、PR流程" class="headerlink" title="一、PR流程"></a>一、PR流程</h1><p>选择社区项目进行 Fork，开发工作应当放在自己的仓库中，个人仓库的 <code>master</code> 分支负责与上游仓库进行同步。</p><p><img src="/img/Open-Source/img-Open-Source.png"></p><p>Clone 个人仓库的项目，在本地开发中，可以同时添加上游仓库源；修改代码时，从最新的 <code>master</code> checkout 到新的临时分支（eg：<code>tmp-branch</code>），在该分支上进行开发，之后 push 到远程个人仓库的一个临时分支（可以直接和本地分支名相同）上。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 添加上游仓库</span><br>git remote add upstream https://github.com/xxx/xxx.git<br><br><span class="hljs-comment"># 创建并切换到新的分支</span><br>git checkout -b tmp-branch<br></code></pre></td></tr></table></figure><p>此时进入上游仓库，可以发现来自个人仓库临时分支的 <code>pull request</code> 提示，点击并填写提交信息，发起合并请求。自动化测试工具通过后，就只需等待社区人员审查，交流通过后便可以将自己的修改合进原项目。此时可以直接删除个人仓库中的临时分支。</p><p>下次修改前需要先将个人仓库的 <code>master</code> 分支与上游仓库进行同步。</p><blockquote><p>一般在社区的首次 PR 请求，会要求贡献者签署 CLA，按照相应的提示操作即可。一些社区也会提供 <code>playground</code> 项目，可以在该项目中练习 PR 的流程，并完成签署 CLA。</p><p>需要注意的是，提交 PR 请求，通过后会根据 PR 的提交信息创建一个新的 commit 点，PR 中个人分支上的多条新 commit 点并不会出现在上游仓库的主分支上。</p></blockquote><h1 id="二、commit-规范"><a href="#二、commit-规范" class="headerlink" title="二、commit 规范"></a>二、commit 规范</h1><h2 id="Angular-提交信息规范"><a href="#Angular-提交信息规范" class="headerlink" title="Angular 提交信息规范"></a>Angular 提交信息规范</h2><p>需要一定的规范来约束开发人员的 commit 信息格式，其中，<a href="https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#-commit-message-guidelines">Angular提交信息规范</a>是一种非常受开发人员欢迎的 commit 信息规范。</p><p>每条 commit message 都由 <strong>header</strong>、<strong>body</strong> 和 <strong>footer</strong> 组成。而 <strong>header</strong> 包括 <strong>type</strong>、<strong>scope</strong> 和 <strong>subject</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">&lt;<span class="hljs-built_in">type</span>&gt;(&lt;scope&gt;): &lt;subject&gt;<br>&lt;BLANK LINE&gt;<br>&lt;body&gt;<br>&lt;BLANK LINE&gt;<br>&lt;footer&gt;<br></code></pre></td></tr></table></figure><p><strong>type</strong> 必须是以下值之一：</p><ul><li><strong>feat</strong>: A new feature</li><li><strong>fix</strong>: A bug fix</li><li><strong>docs</strong>: Documentation only changes</li><li><strong>style</strong>: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)</li><li><strong>refactor</strong>: A code change that neither fixes a bug nor adds a feature</li><li><strong>perf</strong>: A code change that improves performance</li><li><strong>test</strong>: Adding missing or correcting existing tests</li><li><strong>chore</strong>: Changes to the build process or auxiliary tools and libraries such as documentation generation</li></ul><p><strong>subject</strong> 要求：</p><ul><li>以动词开头，使用第一人称现在时，比如 <code>change</code>，而不是 <code>changed</code> 或 <code>changes</code></li><li>不要大写首字母</li><li>不在末尾添加句号</li></ul><h2 id="commitizen"><a href="#commitizen" class="headerlink" title="commitizen"></a>commitizen</h2><p>借助 <strong>commitizen</strong> 可以方便地规范输入 commit 信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 全局安装</span><br>npm install -g commitizen<br>```  <br><br>另一方面，需要安装适配器进行标准提交提示，此处选择 `cz-conventional-changelog`。<br><br>```sh<br><span class="hljs-comment"># 全局安装</span><br>npm install -g cz-conventional-changelog<br><span class="hljs-comment"># 在根目录下添加文件 .czrc，内容如下</span><br>&#123; <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;cz-conventional-changelog&quot;</span> &#125;<br><br><br><span class="hljs-comment"># 本地安装</span><br>npm install --save-dev cz-conventional-changelog<br><span class="hljs-comment"># 在package.json中添加配置</span><br><span class="hljs-string">&quot;config&quot;</span>: &#123;<br>   <span class="hljs-string">&quot;commitizen&quot;</span>: &#123;<br>     <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;cz-conventional-changelog&quot;</span><br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>此时，可以使用 <code>cz</code> 命令代替 <code>git commit</code>，进行规范化 commit 提交。</p><p><img src="/img/Open-Source/img-Open-Source-1.png"></p><h1 id="三、社区术语"><a href="#三、社区术语" class="headerlink" title="三、社区术语"></a>三、社区术语</h1><table><thead><tr><th align="center">缩写</th><th align="center">英文</th><th align="center">中文</th></tr></thead><tbody><tr><td align="center">PR</td><td align="center">Pull request</td><td align="center">拉取请求</td></tr><tr><td align="center">BTW</td><td align="center">By the way</td><td align="center">顺便说一句</td></tr><tr><td align="center">WIP</td><td align="center">Work in progress, do not merge yet</td><td align="center">进行中暂时不要合并</td></tr><tr><td align="center">LGTM</td><td align="center">Looks good to me</td><td align="center">在我看来很好</td></tr><tr><td align="center">PTAL</td><td align="center">Please take a look</td><td align="center">帮我看下，请别人 review 自己的 PR</td></tr><tr><td align="center">CC</td><td align="center">Carbon copy</td><td align="center">抄送</td></tr><tr><td align="center">FYI</td><td align="center">For your information</td><td align="center">供你参考</td></tr><tr><td align="center">RFC</td><td align="center">Request for comments</td><td align="center">我觉得这个想法很好, 我们来一起讨论下</td></tr><tr><td align="center">IIRC</td><td align="center">If I recall correctly</td><td align="center">如果我没记错</td></tr><tr><td align="center">ACK</td><td align="center">Acknowledgement</td><td align="center">认可</td></tr><tr><td align="center">NACK&#x2F;NAK</td><td align="center">Negative acknowledgement</td><td align="center">不认可</td></tr></tbody></table><p>参考：</p><ol><li><a href="https://cloud.tencent.com/developer/article/1602747">Github 常用社交用语 -腾讯云开发者社区-腾讯云 (tencent.com)</a></li><li><a href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines">Angular 提交信息规范</a></li><li><a href="https://www.jianshu.com/p/8564d1281366">使用标准commit生成changelog标准化 - 简书 (jianshu.com)</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>OpenSource</tag>
      
      <tag>Git</tag>
      
      <tag>commitizen</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github Pages + Hexo 搭建个人博客</title>
    <link href="/2024/08/build-blog-by-Hexo/"/>
    <url>/2024/08/build-blog-by-Hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Hexo"><a href="#一、Hexo" class="headerlink" title="一、Hexo"></a>一、Hexo</h1><h2 id="Hexo-安装和基本使用"><a href="#Hexo-安装和基本使用" class="headerlink" title="Hexo 安装和基本使用"></a>Hexo 安装和基本使用</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 准备工作：安装NodeJS</span><br><span class="hljs-comment"># 全局安装Hexo</span><br>npm install -g hexo-cli<br><br><span class="hljs-comment"># 初始化Hexo项目</span><br>hexo init hexo-blog<br><span class="hljs-built_in">cd</span> hexo-blog<br><br><span class="hljs-comment"># 查看目录结构</span><br>tree -L 1<br>.<br>├── _config.landscape.yml<br>├── _config.yml<span class="hljs-comment"># 配置，比如之后在该文件配置github账号</span><br>├── node_modules<br>├── package-lock.json<br>├── package.json<br>├── scaffolds<br>├── <span class="hljs-built_in">source</span><span class="hljs-comment"># source/_posts 存放博客文件（Markdown格式）</span><br>└── themes<span class="hljs-comment"># 更改博客主题皮肤</span><br><br><span class="hljs-comment"># 常用Hexo命令</span><br>hexo init [folder]<span class="hljs-comment"># 初始化</span><br>hexo new [layout] &lt;title&gt;<span class="hljs-comment"># 新建文章</span><br>hexo generate<span class="hljs-comment"># 生成静态文件，根目录生成public文件夹</span><br>hexo server<span class="hljs-comment"># 启动本地服务器，http://localhost:4000/</span><br>hexo deploy<span class="hljs-comment"># 部署到远程 (hexo -g d 生成静态文件并部署)</span><br>hexo clean<span class="hljs-comment"># 清除缓存文件 (db.json) 和已生成的静态文件 (public)</span><br></code></pre></td></tr></table></figure><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>官网提供了多种可选主题 <a href="https://hexo.io/themes/">Themes | Hexo</a></p><p>选择某个主题下载压缩包，以 Fluid 主题为例，在 GitHub 中下载 Releases 包并解压，重命名为 fluid 放在 themes 目录下。</p><p>更改 <code>_config.yml</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">theme: fluid  <span class="hljs-comment"># 指定主题</span><br>language: zh-CN  <span class="hljs-comment"># 指定主题显示语言</span><br></code></pre></td></tr></table></figure><h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 新建</span><br>hexo new my-blog<span class="hljs-comment"># hexo new post my-blog 指定layout</span><br><br><span class="hljs-comment"># 查看变化</span><br>tree <span class="hljs-built_in">source</span>/_posts                                                       <br><span class="hljs-built_in">source</span>/_posts<br>├── hello-world.md<br>└── my-blog.md<br><br><span class="hljs-comment"># 写入内容后本地测试</span><br>hexo s<br></code></pre></td></tr></table></figure><p>通过 <code>new</code> 命令可以在 <code>source/_posts</code> 文件夹下创建相应的 Markdown 文件。</p><p>通常需要在文章中插入图片，为了更规律的管理文章的图片，为每篇文章准备相对应的资源文件夹，将 <code>_config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 后，创建新文章时自动创建一个同名资源文件夹。</p><p>为了使用 Markdown 引用图片，继续改动 <code>_config.yml</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span>  <br><span class="hljs-attr">marked:</span>  <br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span>  <br>  <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>之后可以在文章中直接通过 <code>![](xxx.jpg)</code> 引用对应的图片。</p><p>通过更改主题的 <code>_config.yml</code> 文件可以实现个性化，比如改变主页某处的文字、增加阅读量记录、增加评论功能等，可以根据主题相应的文档进行更改。可以注册 <a href="https://console.leancloud.cn/">LeanCloud</a>，使用其统计服务等功能。</p><h1 id="二、Github-Pages"><a href="#二、Github-Pages" class="headerlink" title="二、Github Pages"></a>二、Github Pages</h1><p>在 <code>Hexo</code> 项目中安装 <code>hexo-deployer-git</code> 包。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>新建仓库，仓库名格式为 <code>&lt;用户名&gt;.github.io</code> ；在 <code>_config.yml</code> 中配置 <code>GitHub</code> 的相关信息。<code>token</code> 可以在 <code>github</code> 的 <code>Settings/Developer Settings</code> 中生成。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:kaysonyu/kaysonyu.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br>  <span class="hljs-attr">token:</span> <span class="hljs-string">xxx</span><br></code></pre></td></tr></table></figure><p>部署到 <code>github</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo -g d<br></code></pre></td></tr></table></figure><blockquote><p>其他相关：Netlify，Vercel，CF Pages</p></blockquote><p>参考：</p><ol><li><a href="https://hexo.io/zh-cn/docs">Hexo 中文文档</a></li><li><a href="https://blog.csdn.net/yaorongke/article/details/119089190">GitHub Pages + Hexo搭建个人博客网站，史上最全教程_hexo博客-CSDN博客</a></li><li><a href="https://hexo.fluid-dev.com/docs/guide/">配置指南 | Hexo Fluid 用户手册 (fluid-dev.com)</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>GithubPages</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将光猫设置为桥接</title>
    <link href="/2024/08/Modem-and-Router/"/>
    <url>/2024/08/Modem-and-Router/</url>
    
    <content type="html"><![CDATA[<p>光猫：光电信号转化。</p><p>路由器：路由扩展网络，WAN 口接上层网络，LAN 口或者无线 WiFi 接扩展设备，形成一个新的局域网。</p><p>光猫设置为路由：</p><p>光猫负责光电信号转化，同时负责拨号上网，此时连接光猫的设备可直接上网，通过 DHCP 获取 ip；此时光猫一侧是外网，一侧是自身形成的局域网（eg：192.168.1.x），通过路由器可以进一步扩展网络。</p><p>光猫设置为桥接：</p><p>此时光猫只负责光电信号转化，起桥梁作用，此时连接路由器后，路由器通过拨号上网，路由器一侧直接是外网（前者路由器一侧是光猫的下属网络），另一侧是路由器下属局域网。这种设置既将拨号负担置于性能更强的路由器（光猫专注于转化工作），又简化了网络的层级关系，将外网-光猫-路由器的网络结构简化为外网-路由器。需要注意的是：仅能单个设备进行拨号，所以改为桥接后不能再将电脑直接连接光猫拨号（路由器已经拨号）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Modem</tag>
      
      <tag>Router</tag>
      
      <tag>DHCP</tag>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu安装记录</title>
    <link href="/2024/08/install-Ubuntu/"/>
    <url>/2024/08/install-Ubuntu/</url>
    
    <content type="html"><![CDATA[<h1 id="安装Ubuntu系统（包含Nvidia驱动）"><a href="#安装Ubuntu系统（包含Nvidia驱动）" class="headerlink" title="安装Ubuntu系统（包含Nvidia驱动）"></a>安装Ubuntu系统（包含Nvidia驱动）</h1><blockquote><p>CPU: i7-14700K</p><p>显卡: GeForce RTX 4060 Ti 16 g</p></blockquote><p>U盘启动后选项如下：</p><p><img src="/img/install-Ubuntu/img-install-Ubuntu.png"></p><blockquote><p>失败记录：</p><p>选择<code>Try or Install Ubuntu</code>无法进入安装界面，一直停留在Ubuntu的加载界面；</p><p>选择<code>Ubuntu(safe graphics)</code>进入安装，但过程中失败，通过log发现有联网需求，之后操作选择使用有线网络；</p><p>重复几次后，突然前两种安装+是否添加<code>nomodeset</code>共四种方法均无法成功安装，选择清空硬盘和U盘并重制启动U盘；</p><p>安装Ubuntu后再次启动一直黑屏无反应，后来将HDMI从显卡换到主板上解决。</p></blockquote><p>步骤：</p><p>由于采用双硬盘双系统的安装策略，所以先拔掉装有Windows的硬盘，防止EFI装在同一块硬盘上。</p><p>选择<code>Ubuntu(safe graphics)</code>，按<code>E</code>进入配置，在<code>quiet splash</code>后面添加<code>nomodeset</code>参数，之后按<code>F10</code>进入Ubuntu 24.04的安装。</p><blockquote><p><code>nouveau</code>是通过逆向得到的非官方的Nvidia驱动，该驱动可能在一些较新的显卡上工作不正常，通过<code>nomodeset</code>来禁止加载该驱动，防止引导时黑屏。</p></blockquote><p>安装后重启拔掉U盘，此时将HDMI换到主板相应接口，否则一直黑屏。</p><blockquote><p>此处针对黑屏的参考资料中提到同样在Ubuntu引导界面进行如上屏蔽<code>nouveau</code>的操作后可以正常进入，但我也没有显示引导界面，完全黑屏，换到主板接口后则无需操作的正常进入系统。</p></blockquote><p>进入系统后需要完全禁止<code>nouveau</code>，使得之后可以自动屏蔽该驱动。之后重启，可以将HDMI重新接到显卡接口。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 编辑黑名单文件</span><br><span class="hljs-built_in">sudo</span> nano /etc/modprobe.d/blacklist.conf<br><span class="hljs-comment"># 在末尾添加如下条目</span><br>blacklist nouveau<br><span class="hljs-comment"># 使黑名单生效</span><br><span class="hljs-built_in">sudo</span> update-initramfs -u<br></code></pre></td></tr></table></figure><blockquote><p>安装Nvidia官方驱动之前可以先检查是否会更换内核版本，我的版本中无线网卡未成功工作，升级了Linux内核版本，但由于安装后的Nvidia驱动在切换版本后不生效，所以后来进行了卸载重装，具体留在无线网卡部分。</p></blockquote><p>之后安装Nvidia官方驱动，在官网下载对应显卡的驱动程序。此时直接运行会遇到各种问题：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 问题</span><br>WARNING: Unable to find suitable destination to install 32-bit compatibility libraries<br><span class="hljs-comment"># 解决</span><br><span class="hljs-built_in">sudo</span> dpkg --add-architecture i386<br><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt install libc6:i386<br><br><span class="hljs-comment"># 问题</span><br>An incomplete installation of libglvnd was found.                   <br>All of the essential libglvnd libraries are present, but one or more optional  components are missing.<br>Do you want to install a full copy of libglvnd? This will overwrite any existing libglvnd libraries.<br><span class="hljs-comment"># 解决</span><br><span class="hljs-built_in">sudo</span> apt install libglvnd-dev<br><br><span class="hljs-comment"># 问题</span><br>WARNING: Unable to determine the path to install the libglvnd EGL vendor library config files.<br>Check that you have pkg-config and the libglvnd development libraries installed, or specify a path with --glvnd-egl-config-path.<br><span class="hljs-comment"># 解决</span><br><span class="hljs-built_in">sudo</span> apt install pkg-config<br></code></pre></td></tr></table></figure><p>所以安装前先进行下载：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> dpkg --add-architecture i386<br><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt install libc6:i386<br><span class="hljs-built_in">sudo</span> apt install build-essential libglvnd-dev pkg-config<br><span class="hljs-comment"># 停止当前显示服务器</span><br><span class="hljs-built_in">sudo</span> telinit 3<br><span class="hljs-comment"># 运行驱动安装</span><br><span class="hljs-built_in">sudo</span> bash NVIDIA-Linux-x86_64-550.107.02.run<br><span class="hljs-comment"># 重启</span><br><span class="hljs-built_in">sudo</span> reboot<br></code></pre></td></tr></table></figure><p>驱动安装完成。</p><p><img src="/img/install-Ubuntu/img-install-Ubuntu-1.png"></p><h1 id="中文输入法"><a href="#中文输入法" class="headerlink" title="中文输入法"></a>中文输入法</h1><p>在 <code>Settings</code> 的 <code>Region &amp; Language</code> 中安装汉语，应用并重启。</p><p>在<code>Keyboard</code>中添加拼音键入。</p><h1 id="卸载snap（安装Chrome）"><a href="#卸载snap（安装Chrome）" class="headerlink" title="卸载snap（安装Chrome）"></a>卸载snap（安装Chrome）</h1><p>先安装Chrome（之后需要卸载snap版的Firefox），下载deb包，调用<code>sudo dpkg -i xxx.deb</code>安装即可。</p><p>卸载snap：</p><p>删除已安装的 Snap 软件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 多执行几次</span><br><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> $(snap list | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>); <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">sudo</span> snap remove <span class="hljs-variable">$p</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-comment"># 成功效果</span><br>snaps are installed yet. Try <span class="hljs-string">&#x27;snap install hello-world&#x27;</span>.  <br></code></pre></td></tr></table></figure><p>（删除 Snap 的 Core 文件）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> systemctl stop snapd                                           <br><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">disable</span> --now snapd.socket<br><span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> /snap/core/*; <span class="hljs-keyword">do</span><br>   <span class="hljs-built_in">sudo</span> umount <span class="hljs-variable">$m</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>删除 Snap 管理工具</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> apt autoremove --purge snapd<br></code></pre></td></tr></table></figure><p>删除 Snap 的目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">rm</span> -rf ~/snap                                                       <br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> -rf /snap<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> -rf /var/snap<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> -rf /var/lib/snapd<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> -rf /var/cache/snapd<br></code></pre></td></tr></table></figure><p>禁止 apt 安装 snapd</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> nano /etc/apt/preferences.d/no-snapd.pref<br><span class="hljs-comment"># 文件内容</span><br>Package: snapd                                                     <br>Pin: release a=*<br>Pin-Priority: -10<br></code></pre></td></tr></table></figure><h1 id="安装Clash"><a href="#安装Clash" class="headerlink" title="安装Clash"></a>安装Clash</h1><p>Clash_for_Windows资源站：<a href="https://archive.org/download/clash_for_windows_pkg">https://archive.org/download/clash_for_windows_pkg</a></p><p>下载并解压</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -zxvf Clash.for.Windows-0.18.5-x64-linux.tar.gz<br><span class="hljs-built_in">mv</span> Clash.for.Windows-0.18.5-x64-linux clash<br><span class="hljs-built_in">cd</span> Clash<br>./cfw<br></code></pre></td></tr></table></figure><p>导入订阅</p><p>设置系统代理</p><p><img src="/img/install-Ubuntu/img-install-Ubuntu-2.png"></p><h1 id="美化主题"><a href="#美化主题" class="headerlink" title="美化主题"></a>美化主题</h1><p>美化项：</p><ul><li><p>图标主题：更改图标主题将更改应用程序图标的外观，最好选择支持各种应用程序的图标主题，否则可能会看到一些图标外观保持不变甚至看起来不合适。</p></li><li><p>GTK 主题：GTK 是用于构建应用程序的图形用户界面的框架。基本上，它决定了应用程序界面的外观（前提是这个应用程序是 GTK 应用程序，大部分的系统应用程序都是 GTK 应用程序）。</p></li><li><p>GNOME Shell 主题：更改 GNOME Shell 主题将更改 Shell 元素，例如顶部面板、活动概览、桌面通知等。</p></li><li><p>光标主题</p></li></ul><p>环境安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 安装tweak工具，添加名为Tweak的应用程序，可以用来更改主题、图标等</span><br><span class="hljs-built_in">sudo</span> apt install gnome-tweaks<br><span class="hljs-comment"># 可以在chrome中下载gnome-shell扩展，https://extensions.gnome.org/</span><br><span class="hljs-built_in">sudo</span> apt install chrome-gnome-shell<br><span class="hljs-comment"># 添加名为Extensions的应用程序，可以进行gnome-shell扩展的管理与配置</span><br><span class="hljs-built_in">sudo</span> apt install gnome-shell-extensions<br></code></pre></td></tr></table></figure><p>在扩展中，启用<code>User Themes</code>后可以在<code>Tweak</code>中进行Shell主题的更改，启动<code>Dash to Dock</code>后可以灵活美观的控制Dock栏。</p><p>主题下载地址：<a href="https://www.opendesktop.org/">https://www.opendesktop.org/</a></p><p>存放位置：</p><ul><li><p>~&#x2F;.themes：GTK 主题，GNOME Shell 主题</p></li><li><p>~&#x2F;.icons：图标主题，光标主题</p></li></ul><h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><p>安装Zsh并使用其作为Shell</p><p>安装Zim并借助其安装p10k主题以及其他插件，见Shell文章</p><h1 id="更换Linux内核"><a href="#更换Linux内核" class="headerlink" title="更换Linux内核"></a>更换Linux内核</h1><p>板载无线网卡无法使用，由<code>lshw</code>命令可以得到无线网卡品牌为<code>WCN785x Wi-Fi 7(802.11be) 320MHz 2x2 [FastConnect 7800]</code>，对比下面的以太网，该无线网卡没有合适的驱动程序。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># lshw</span><br>lshw -C network                                                          <br>WARNING: you should run this program as super-user.<br>  *-network                 <br>       description: Network controller<br>       product: WCN785x Wi-Fi 7(802.11be) 320MHz 2x2 [FastConnect 7800]<br>       vendor: Qualcomm Technologies, Inc<br>       physical <span class="hljs-built_in">id</span>: 0<br>       bus info: pci@0000:06:00.0<br>       version: 01<br>       width: 64 bits<br>       clock: 33MHz<br>       capabilities: bus_master cap_list<br>       configuration: driver=ath12k_pci latency=0<br>       resources: irq:204 memory:82200000-823fffff<br>  *-network<br>       description: Ethernet interface<br>       product: Ethernet Controller I225-V<br>       vendor: Intel Corporation<br>       physical <span class="hljs-built_in">id</span>: 0<br>       bus info: pci@0000:07:00.0<br>       logical name: enp7s0<br>       version: 03<br>       serial: d8:43:ae:79:a2:80<br>       size: 100Mbit/s<br>       capacity: 1Gbit/s<br>       width: 32 bits<br>       clock: 33MHz<br>       capabilities: bus_master cap_list ethernet physical tp 10bt 10bt-fd 100bt 100bt-fd 1000bt-fd autonegotiation<br>       configuration: autonegotiation=on broadcast=<span class="hljs-built_in">yes</span> driver=igc driverversion=6.8.0-39-generic duplex=full firmware=1073:8754 ip=192.168.1.2 latency=0 <span class="hljs-built_in">link</span>=<span class="hljs-built_in">yes</span> multicast=<span class="hljs-built_in">yes</span> port=twisted pair speed=100Mbit/s<br>       resources: irq:19 memory:82e00000-82efffff memory:82f00000-82f03fff<br>WARNING: output may be incomplete or inaccurate, you should run this program as super-user.<br><br><span class="hljs-comment"># dmesg</span><br><span class="hljs-built_in">sudo</span> dmesg<br>...<br>[    5.453515] ath12k_pci 0000:06:00.0: chip_id 0x2 chip_family 0x4 board_id 0xff soc_id 0x40170200<br>[    5.453526] ath12k_pci 0000:06:00.0: fw_version 0x100301e1 fw_build_timestamp 2023-12-06 04:05 fw_build_id QC_IMAGE_VERSION_STRING=WLAN.HMT.1.0.c5-00481-QCAHMTSWPL_V1.0_V2.0_SILICONZ-3<br>[    5.453650] ath12k_pci 0000:06:00.0: qmi failed to load regdb bin:<br>[    5.453653] ath12k_pci 0000:06:00.0: qmi failed to load regdb file:-2<br>...<br></code></pre></td></tr></table></figure><p>通过查阅<a href="https://askubuntu.com/questions/1513315/issue-with-wireless-network-connection-on-ubuntu-24-04-lts">相关问题</a>，得知可以通过更换最新稳定版的Linux内核（提供了相应的<code>Wi-Fi 7</code>的驱动）来解决。</p><p>查看当前内核版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">uname</span> -r                                                            <br>6.8.0-39-generic<br></code></pre></td></tr></table></figure><p>安装最新的稳定版内核：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 下载最新的稳定版内核</span><br>wget -c https://kernel.ubuntu.com/mainline/v6.10.2/amd64/linux-headers-6.10.2-061002_6.10.2-061002.202407271100_all.deb<br>wget -c https://kernel.ubuntu.com/mainline/v6.10.2/amd64/linux-headers-6.10.2-061002-generic_6.10.2-061002.202407271100_amd64.deb<br>wget -c https://kernel.ubuntu.com/mainline/v6.10.2/amd64/linux-image-unsigned-6.10.2-061002-generic_6.10.2-061002.202407271100_amd64.deb<br>wget -c https://kernel.ubuntu.com/mainline/v6.10.2/amd64/linux-modules-6.10.2-061002-generic_6.10.2-061002.202407271100_amd64.deb <br><br><span class="hljs-comment"># 安装</span><br><span class="hljs-built_in">sudo</span> dpkg -i *.deb<br><br><span class="hljs-comment"># 重启</span><br><span class="hljs-built_in">sudo</span> reboot<br><br><span class="hljs-comment"># 验证</span><br><span class="hljs-built_in">uname</span> -r<br>6.10.2-061002-generic<br></code></pre></td></tr></table></figure><p>更换到<code>6.10.2</code>版本的内核后，可以搜索到无线网络，表明驱动正常工作。但是，<code>nvidia-smi</code>失败，更换Linux内核版本会导致Nvidia驱动发生问题，所以可以先选择合适的内核版本。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">nmcli device status<br>DEVICE          TYPE      STATE                   CONNECTION         <br>enp7s0          ethernet  connected               Wired connection 1 <br>wlp6s0          wifi      connected               TP-LINK_9B19       <br>lo              loopback  connected (externally)  lo                 <br>p2p-dev-wlp6s0  wifi-p2p  disconnected            --      <br></code></pre></td></tr></table></figure><p>从当前存在的内核版本间切换：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 列出当前所有内核版本，每个menuentry项是一个内核</span><br><span class="hljs-built_in">sudo</span> grep menuentry /boot/grub/grub.cfg<br><span class="hljs-keyword">if</span> [ x<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;feature_menuentry_id&#125;</span>&quot;</span> = xy ]; <span class="hljs-keyword">then</span><br>  menuentry_id_option=<span class="hljs-string">&quot;--id&quot;</span><br>  menuentry_id_option=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-built_in">export</span> menuentry_id_option<br>menuentry <span class="hljs-string">&#x27;Ubuntu&#x27;</span> --class ubuntu --class gnu-linux --class gnu --class os <span class="hljs-variable">$menuentry_id_option</span> <span class="hljs-string">&#x27;gnulinux-simple-dbc01096-0009-4726-8fa2-076494d33602&#x27;</span> &#123;<br>submenu <span class="hljs-string">&#x27;Advanced options for Ubuntu&#x27;</span> <span class="hljs-variable">$menuentry_id_option</span> <span class="hljs-string">&#x27;gnulinux-advanced-dbc01096-0009-4726-8fa2-076494d33602&#x27;</span> &#123;<br>    menuentry <span class="hljs-string">&#x27;Ubuntu, with Linux 6.10.2-061002-generic&#x27;</span> --class ubuntu --class gnu-linux --class gnu --class os <span class="hljs-variable">$menuentry_id_option</span> <span class="hljs-string">&#x27;gnulinux-6.10.2-061002-generic-advanced-dbc01096-0009-4726-8fa2-076494d33602&#x27;</span> &#123;<br>    menuentry <span class="hljs-string">&#x27;Ubuntu, with Linux 6.10.2-061002-generic (recovery mode)&#x27;</span> --class ubuntu --class gnu-linux --class gnu --class os <span class="hljs-variable">$menuentry_id_option</span> <span class="hljs-string">&#x27;gnulinux-6.10.2-061002-generic-recovery-dbc01096-0009-4726-8fa2-076494d33602&#x27;</span> &#123;<br>    menuentry <span class="hljs-string">&#x27;Ubuntu, with Linux 6.8.0-39-generic&#x27;</span> --class ubuntu --class gnu-linux --class gnu --class os <span class="hljs-variable">$menuentry_id_option</span> <span class="hljs-string">&#x27;gnulinux-6.8.0-39-generic-advanced-dbc01096-0009-4726-8fa2-076494d33602&#x27;</span> &#123;<br>    menuentry <span class="hljs-string">&#x27;Ubuntu, with Linux 6.8.0-39-generic (recovery mode)&#x27;</span> --class ubuntu --class gnu-linux --class gnu --class os <span class="hljs-variable">$menuentry_id_option</span> <span class="hljs-string">&#x27;gnulinux-6.8.0-39-generic-recovery-dbc01096-0009-4726-8fa2-076494d33602&#x27;</span> &#123;<br>menuentry <span class="hljs-string">&quot;Memory test (memtest86+x64.efi)&quot;</span> --class memtest <span class="hljs-variable">$menuentry_id_option</span> <span class="hljs-string">&#x27;memtest86+&#x27;</span> &#123;<br>menuentry <span class="hljs-string">&#x27;Memory test (memtest86+x64.efi, serial console)&#x27;</span> --class memtest <span class="hljs-variable">$menuentry_id_option</span> <span class="hljs-string">&#x27;memtest86+-serial&#x27;</span> &#123;<br>        menuentry <span class="hljs-string">&#x27;UEFI Firmware Settings&#x27;</span> <span class="hljs-variable">$menuentry_id_option</span> <span class="hljs-string">&#x27;uefi-firmware&#x27;</span> &#123;<br><br><span class="hljs-comment"># 更改默认启动内核，将文件中的`GRUB_DEFAULT=0`改为相应的`GRUB_DEFAULT=&quot;1&gt; ?&quot;`</span><br><span class="hljs-built_in">sudo</span> nano /etc/default/grub<br>GRUB_DEFAULT=<span class="hljs-string">&quot;1&gt; 2&quot;</span> <span class="hljs-comment"># 改回`Ubuntu, with Linux 6.8.0-39-generic`</span><br></code></pre></td></tr></table></figure><p>参考：</p><ol><li><p><a href="https://www.onitroad.com/jc/linux/ubuntu/faq/how-to-install-the-nvidia-drivers-on-ubuntu-20-04.html">如何在Ubuntu 20.04 Linux上安装NVIDIA驱动程序</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1wY411p7mU">NVIDIA显卡的Ubuntu驱动程序安装方法</a></p></li><li><p><a href="https://sysin.cn/blog/ubuntu-remove-snap/">删除 Snap 的方法</a></p></li><li><p><a href="https://www.joeyne.cool/http/proxy/ubuntu-%E5%AE%89%E8%A3%85clash%E5%B9%B6%E9%85%8D%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/">Ubuntu 配置clash的四种方式</a></p></li><li><p><a href="https://blog.csdn.net/weixin_44267654/article/details/133773997">Ubuntu 23 安装Gnome主题</a></p></li><li><p><a href="https://www.cnblogs.com/WHU-TD/p/14010786.html">GNOME 桌面美化</a></p></li><li><p><a href="https://itsfoss.com/install-themes-ubuntu/">How to Install Themes in Ubuntu Linux</a></p></li><li><p><a href="https://askubuntu.com/questions/1513315/issue-with-wireless-network-connection-on-ubuntu-24-04-lts">Issue with Wireless Network Connection on Ubuntu 24.04 LTS</a></p></li><li><p><a href="https://sypalo.com/how-to-upgrade-ubuntu">How to upgrade Ubuntu to 24.04 and kernel to latest version</a></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>zsh</tag>
      
      <tag>Ubuntu</tag>
      
      <tag>Nvidia</tag>
      
      <tag>Snap</tag>
      
      <tag>Gnome</tag>
      
      <tag>kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu包管理</title>
    <link href="/2024/08/package-management/"/>
    <url>/2024/08/package-management/</url>
    
    <content type="html"><![CDATA[<h1 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h1><p>APT 是基于 Ubuntu&#x2F;Debian 的 Linux 发行版上的默认包管理器。</p><p>常用命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 列出所有可更新的软件清单命令</span><br><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-comment"># 升级软件包</span><br><span class="hljs-built_in">sudo</span> apt upgrade<br><span class="hljs-comment"># 列出可更新的软件包及版本信息</span><br>apt list --upgradable<br><span class="hljs-comment"># 列出所有已安装的包</span><br>apt list --installed<br><span class="hljs-comment"># 列出所有已安装的包的版本信息</span><br>apt list --all-versions<br><span class="hljs-comment"># 安装指定的软件命令</span><br><span class="hljs-built_in">sudo</span> apt install &lt;package_name&gt;<br><span class="hljs-comment"># 更新指定的软件命令</span><br><span class="hljs-built_in">sudo</span> apt update &lt;package_name&gt;<br><span class="hljs-comment"># 显示软件包具体信息,例如：版本号，安装大小，依赖关系等等</span><br><span class="hljs-built_in">sudo</span> apt show &lt;package_name&gt;<br><span class="hljs-comment"># 删除软件包命令</span><br><span class="hljs-built_in">sudo</span> apt remove &lt;package_name&gt;<br><span class="hljs-comment"># 清理不再使用的依赖和库文件</span><br><span class="hljs-built_in">sudo</span> apt autoremove<br><span class="hljs-comment"># 移除软件包及配置文件</span><br><span class="hljs-built_in">sudo</span> apt purge &lt;package_name&gt;<br><span class="hljs-comment"># 查找软件包命令</span><br><span class="hljs-built_in">sudo</span> apt search &lt;keyword&gt;<br></code></pre></td></tr></table></figure><h1 id="软件包存储库"><a href="#软件包存储库" class="headerlink" title="软件包存储库"></a>软件包存储库</h1><p>Ubuntu 软件包存储库信息存储在 <strong>&#x2F;etc&#x2F;apt&#x2F;sources.list</strong> 文件中。第三方 PPA 和其他存储库作为 <strong>.list</strong> 文件存储在 <strong>&#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;</strong> 目录中。</p><p>下面为 Ubuntu22.04LTS 的 <strong>&#x2F;etc&#x2F;apt&#x2F;sources.list</strong> 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to</span><br><span class="hljs-comment"># newer versions of the distribution.</span><br><span class="hljs-string">deb</span> <span class="hljs-string">http://archive.ubuntu.com/ubuntu/</span> <span class="hljs-string">jammy</span> <span class="hljs-string">main</span> <span class="hljs-string">restricted</span><br><span class="hljs-comment"># deb-src http://archive.ubuntu.com/ubuntu/ jammy main restricted</span><br><br><span class="hljs-comment">## Major bug fix updates produced after the final release of the</span><br><span class="hljs-comment">## distribution.</span><br><span class="hljs-string">deb</span> <span class="hljs-string">http://archive.ubuntu.com/ubuntu/</span> <span class="hljs-string">jammy-updates</span> <span class="hljs-string">main</span> <span class="hljs-string">restricted</span><br><span class="hljs-comment"># deb-src http://archive.ubuntu.com/ubuntu/ jammy-updates main restricted</span><br><br><span class="hljs-comment">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span><br><span class="hljs-comment">## team. Also, please note that software in universe WILL NOT receive any</span><br><span class="hljs-comment">## review or updates from the Ubuntu security team.</span><br><span class="hljs-string">deb</span> <span class="hljs-string">http://archive.ubuntu.com/ubuntu/</span> <span class="hljs-string">jammy</span> <span class="hljs-string">universe</span><br><span class="hljs-comment"># deb-src http://archive.ubuntu.com/ubuntu/ jammy universe</span><br><span class="hljs-string">deb</span> <span class="hljs-string">http://archive.ubuntu.com/ubuntu/</span> <span class="hljs-string">jammy-updates</span> <span class="hljs-string">universe</span><br><span class="hljs-comment"># deb-src http://archive.ubuntu.com/ubuntu/ jammy-updates universe</span><br><br><span class="hljs-comment">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span><br><span class="hljs-comment">## team, and may not be under a free licence. Please satisfy yourself as to</span><br><span class="hljs-comment">## your rights to use the software. Also, please note that software in</span><br><span class="hljs-comment">## multiverse WILL NOT receive any review or updates from the Ubuntu</span><br><span class="hljs-comment">## security team.</span><br><span class="hljs-string">deb</span> <span class="hljs-string">http://archive.ubuntu.com/ubuntu/</span> <span class="hljs-string">jammy</span> <span class="hljs-string">multiverse</span><br><span class="hljs-comment"># deb-src http://archive.ubuntu.com/ubuntu/ jammy multiverse</span><br><span class="hljs-string">deb</span> <span class="hljs-string">http://archive.ubuntu.com/ubuntu/</span> <span class="hljs-string">jammy-updates</span> <span class="hljs-string">multiverse</span><br><span class="hljs-comment"># deb-src http://archive.ubuntu.com/ubuntu/ jammy-updates multiverse</span><br><br><span class="hljs-comment">## N.B. software from this repository may not have been tested as</span><br><span class="hljs-comment">## extensively as that contained in the main release, although it includes</span><br><span class="hljs-comment">## newer versions of some applications which may provide useful features.</span><br><span class="hljs-comment">## Also, please note that software in backports WILL NOT receive any review</span><br><span class="hljs-comment">## or updates from the Ubuntu security team.</span><br><span class="hljs-string">deb</span> <span class="hljs-string">http://archive.ubuntu.com/ubuntu/</span> <span class="hljs-string">jammy-backports</span> <span class="hljs-string">main</span> <span class="hljs-string">restricted</span> <span class="hljs-string">universe</span> <span class="hljs-string">multiverse</span><br><span class="hljs-comment"># deb-src http://archive.ubuntu.com/ubuntu/ jammy-backports main restricted universe multiverse</span><br><br><span class="hljs-string">deb</span> <span class="hljs-string">http://security.ubuntu.com/ubuntu/</span> <span class="hljs-string">jammy-security</span> <span class="hljs-string">main</span> <span class="hljs-string">restricted</span><br><span class="hljs-comment"># deb-src http://security.ubuntu.com/ubuntu/ jammy-security main restricted</span><br><span class="hljs-string">deb</span> <span class="hljs-string">http://security.ubuntu.com/ubuntu/</span> <span class="hljs-string">jammy-security</span> <span class="hljs-string">universe</span><br><span class="hljs-comment"># deb-src http://security.ubuntu.com/ubuntu/ jammy-security universe</span><br><span class="hljs-string">deb</span> <span class="hljs-string">http://security.ubuntu.com/ubuntu/</span> <span class="hljs-string">jammy-security</span> <span class="hljs-string">multiverse</span><br><span class="hljs-comment"># deb-src http://security.ubuntu.com/ubuntu/ jammy-security multiverse</span><br></code></pre></td></tr></table></figure><p><strong>deb-src deb</strong></p><p><strong>deb-src</strong>: 包含软件源代码、版本修改说明、构建指令以及编译工具等。允许用户下载软件包的源代码，从而可以自己编译软件。这通常用于开发者或那些需要定制软件包或需要最新开发版本的用户。</p><p><strong>deb</strong>: 包含可执行文件、库文件、配置文件、man&#x2F;info页面、版权声明和其它文档。提供了预先编译好的软件包，用户可以直接安装而无需自己编译。</p><p><strong>jammy</strong>: Ubuntu22.04 代号</p><ul><li><p>Ubuntu 18.04 LTS bionic</p></li><li><p>Ubuntu 20.04 LTS focal</p></li><li><p>Ubuntu 22.04 LTS jammy</p></li><li><p>Ubuntu 24.04 LTS noble</p></li></ul><p><strong>main restricted universe multiverse</strong> 软件包存储库</p><ul><li><p><strong>main</strong>: 保留了Ubuntu支持的自由和开源软件。</p></li><li><p><strong>restricted</strong>: 保留专有驱动程序（即 NVIDIA）。</p></li><li><p><strong>universe</strong>: 保留了社区维护的免费开源软件。</p></li><li><p><strong>multiverse</strong>: 保留有版权限制或法律问题的软件。</p></li></ul><p><strong>jammy jammy-security jammy-backports jammy-updates jammy-proposed</strong> 不同分支</p><ul><li><p><strong>基础</strong>：由于ubuntu是每6个月发行一个新版，当发行后，所有软件包的版本在这六个月内将保持不变，即使是有新版都不更新。除开重要的安全补丁外，所有新功能和非安全性补丁将不会提供给用户更新。  </p></li><li><p><strong>security</strong>：仅修复漏洞，并且尽可能少的改变软件包的行为，低风险。</p></li><li><p><strong>backports</strong>：backports 的团队则认为最好的更新策略是 security 策略加上新版本的软件（包括候选版本的），但不会由Ubuntu security team审查和更新。</p></li><li><p><strong>updates</strong>：包含了针对特定版本的更新，这些更新是在原始版本发布之后提供的，可能包括安全修复、bug修复和一些较小的功能改进。  </p></li><li><p><strong>proposed</strong>：updates类的测试部分，仅建议提供测试和反馈的人进行安装。</p></li></ul><h1 id="dpkg"><a href="#dpkg" class="headerlink" title="dpkg"></a>dpkg</h1><p>dpkg是Debian的一个底层包管理工具，主要用于对已下载到本地和已安装的软件包进行管理。</p><p>常用命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">dpkg -i &lt;package&gt;  <span class="hljs-comment"># 安装一个在本地文件系统上存在的Debian软件包</span><br>dpkg -r &lt;package&gt;  <span class="hljs-comment"># 移除一个已经安装的软件包</span><br>dpkg -P &lt;package&gt;  <span class="hljs-comment"># 移除已安装软件包及配置文件</span><br>dpkg -L &lt;package&gt;  <span class="hljs-comment"># 列出安装的软件包清单</span><br>dpkg -s &lt;package&gt;  <span class="hljs-comment"># 显出软件包的安装状态</span><br></code></pre></td></tr></table></figure><p>参考：</p><ol><li><p><a href="https://forum.ubuntu.com.cn/viewtopic.php?f=77&t=253103">源中的 backports proposed security updates 的意思（已解决） - Ubuntu中文论坛</a></p></li><li><p><a href="https://www.runoob.com/linux/linux-comm-apt.html">Linux apt 命令 | 菜鸟教程 (runoob.com)</a></p></li><li><p><a href="https://blog.csdn.net/challenglistic/article/details/127825934">Ubuntu 软件包管理工具 —— dkpg、apt（dpkg常用指令、apt 软件源的配置）-CSDN博客</a></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>apt</tag>
      
      <tag>dpkg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell</title>
    <link href="/2024/07/Shell/"/>
    <url>/2024/07/Shell/</url>
    
    <content type="html"><![CDATA[<h1 id="Shell分类"><a href="#Shell分类" class="headerlink" title="Shell分类"></a>Shell分类</h1><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>Windows has two command-line shells:</p><ul><li><p>the Command shell (cmd)</p></li><li><p>PowerShell</p></li></ul><p>cmd可以运行win命令；PowerShell可以运行win命令和cmdlet命令。</p><p>cmd脚本语言<code>.bat</code>；PowerShell脚本语言<code>.ps1</code></p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>sh, csh, tcsh, bash, zsh, fish…</p><p><strong>Bash Shell</strong></p><p>1989 年首次发布，由 Brain Fox 为 GNU 项目编写的，目的是作为 Bourne Shell (sh) 的免费软件替代品，是大多数 Linux 发行版的默认 Shell 环境。</p><p>用户配置设置在 <code>.bashrc</code> 中。</p><p><strong>Z Shell</strong></p><p>1990 年由 Paul Falstad 发布，它具有 Bash、Korn Shell 和 C Shell 共有的一些功能，macOS 默认使用 Zsh Shell。</p><p>比 Bash 可配置度更高，有围绕 Z Shell 构建的框架（Oh My Zsh）。</p><p>用户配置设置在 <code>.zshrc</code> 中。</p><p><strong>Fish Shell</strong></p><p>2005 年由 Axel Liljencrantz 创建，不符合 POSIX shell 标准。</p><p>由于默认情况下 Fish 已经预置了很多配置，因此它被认为比 Zsh 等其他 <code>sh</code> 选项更适合初学者。</p><h1 id="自定义工具"><a href="#自定义工具" class="headerlink" title="自定义工具"></a>自定义工具</h1><p>查看&#x2F;切换shell</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看可用shell</span><br><span class="hljs-built_in">cat</span> /etc/shells                          <br><span class="hljs-comment"># /etc/shells: valid login shells</span><br>/bin/sh<br>/bin/bash<br>/usr/bin/bash<br>/bin/rbash<br>/usr/bin/rbash<br>/usr/bin/sh<br>/bin/dash<br>/usr/bin/dash<br>/usr/bin/tmux<br>/usr/bin/screen<br>/bin/zsh<br>/usr/bin/zsh<br><br><span class="hljs-comment"># 查看当前shell</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span>                                                            <br><br><span class="hljs-comment"># 可以通过包管理器安装zsh</span><br><span class="hljs-comment"># 切换成zsh</span><br>chsh -s $(<span class="hljs-built_in">which</span> zsh)<br></code></pre></td></tr></table></figure><p>一些主题中的部件需要特殊字体，下载使用使用Nerd字体。</p><p>Window：<a href="https://www.nerdfonts.com/">官网</a>下载MesloLG Nerd Font，将所有的<code>TrueType字体文件</code>右键进行安装。</p><p>MacOS&#x2F;Linux：脚本安装。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/ryanoasis/nerd-fonts.git --depth 1<br><span class="hljs-built_in">cd</span> nerd-fonts<br>./install.sh<br></code></pre></td></tr></table></figure><h2 id="Oh-my-zsh"><a href="#Oh-my-zsh" class="headerlink" title="Oh my zsh"></a>Oh my zsh</h2><p>适用于zsh。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 安装命令</span><br>sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span><br><span class="hljs-comment"># 卸载</span><br>uninstall_oh_my_zsh<br></code></pre></td></tr></table></figure><p>安装后<code>~/.zshrc</code>会改变，从而启动oh-my-zsh，此时终端如下：</p><p><img src="/img/Shell/img-Shell.png"></p><p>之后可以下载主题和插件，一方面要将下载保存到<code>$ZSH_CUSTOM</code>(<del>&#x2F;.oh-my-zsh&#x2F;custom)，另一方面要在&#96;</del>&#x2F;.zshrc&#96;进行相应设置以生效。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 主题$ZSH_CUSTOM/themes，插件$ZSH_CUSTOM/plugins</span><br><span class="hljs-comment"># powerlevel10k主题  </span><br>git <span class="hljs-built_in">clone</span> https://github.com/romkatv/powerlevel10k.git <span class="hljs-variable">$ZSH_CUSTOM</span>/themes/powerlevel10k  <br><span class="hljs-comment"># zsh-autosuggestions自动提示插件  </span><br>git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="hljs-variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions  <br><span class="hljs-comment"># zsh-syntax-highlighting语法高亮插件  </span><br>git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="hljs-variable">$ZSH_CUSTOM</span>/plugins/zsh-syntax-highlighting<br><br><span class="hljs-comment"># 对于p10k，需要进行自定义配置</span><br>p10k configure<br><br><span class="hljs-comment"># ~/.zshrc</span><br><span class="hljs-comment"># 修改主题  </span><br>ZSH_THEME=<span class="hljs-string">&quot;powerlevel10k/powerlevel10k&quot;</span>  <br><br><span class="hljs-comment"># 启用插件  </span><br>plugins=(  <br>  git  <br>  zsh-autosuggestions  <br>  zsh-syntax-highlighting  <br>)<br><br><span class="hljs-comment"># 更改配置后重载</span><br>omz reload<br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="/img/Shell/img-Shell-1.png"></p><h2 id="Zim"><a href="#Zim" class="headerlink" title="Zim"></a>Zim</h2><p>Zim 启动速度更快，相比 oh-my-zsh 更加轻量级，适用于zsh。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 安装命令</span><br>curl -fsSL https://raw.githubusercontent.com/zimfw/install/master/install.zsh | zsh<br></code></pre></td></tr></table></figure><p>安装后<code>~/.zshrc</code>会改变，而Zim的配置文件为<code>~/.zimrc</code>，在该文件中列出需要使用的插件（包括主题），比如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">zmodule romkatv/powerlevel10k<br>zmodule completion<br></code></pre></td></tr></table></figure><p>之后运行<code>zimfw install</code>来安装所需插件，与oh-my-zsh类似，同样需要配置<code>p10k</code>主题。</p><p>效果展示：</p><p><img src="/img/Shell/img-Shell-2.png"></p><h2 id="Oh-my-posh"><a href="#Oh-my-posh" class="headerlink" title="Oh my posh"></a>Oh my posh</h2><p>可以用于多种shell。</p><p><img src="/img/Shell/img-Shell-3.png"></p><p>可以在Windows中美化PowerShell的样式。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 安装命令</span><br>winget upgrade JanDeDobbeleer.OhMyPosh -s winget<br></code></pre></td></tr></table></figure><p>Windows中自带蓝色的Windows PowerShell，可以在Microsoft Store中下载黑色的PowerShell，本文使用黑色的PowerShell作为终端的默认shell。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看使用的shell</span><br>oh-my-posh get shell<br><br><span class="hljs-comment"># PowerShell配置脚本文件位置（类似~/.zshrc）</span><br>(base) PS C:\Users\kangy&gt; <span class="hljs-variable">$PROFILE</span><br>C:\Users\kangy\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1<br><span class="hljs-comment"># 编辑PowerShell配置文件脚本</span><br>notepad <span class="hljs-variable">$PROFILE</span><br><span class="hljs-comment"># 若文件不存在则创建</span><br>New-Item -Path <span class="hljs-variable">$PROFILE</span> -Type File -Force<br><span class="hljs-comment"># 在脚本中添加如下启动oh-my-posh并使主题生效</span><br>&amp; ([ScriptBlock]::Create((oh-my-posh init pwsh --config &quot;<span class="hljs-variable">$env</span>:POSH_THEMES_PATH\jandedobbeleer.omp.json&quot; --print) -join &quot;`n&quot;))<br><br><span class="hljs-comment"># 重载shell</span><br>. <span class="hljs-variable">$PROFILE</span><br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="/img/Shell/img-Shell-4.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>zsh</tag>
      
      <tag>oh-my-zsh</tag>
      
      <tag>zim</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
